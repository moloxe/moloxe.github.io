{
  "title": "Aut√≥matas celulares en GLSL",
  "creationDate": "2024-06-23T23:08:25.980Z",
  "lastUpdate": "2024-09-02T05:07:28.136Z",
  "categories": [
    "tech",
    "edu",
    "art"
  ],
  "container": [
    {
      "text": "Tercera y √∫ltima continuaci√≥n espiritual de [shaders en corto](/blog/shaders-en-corto). Con este post me voy de vacaciones de los shaders. Probablemente los siga usando, pero no escribir√© m√°s posts enfocados en GLSL.",
      "type": "MarkdownBlock"
    },
    {
      "text": "Un adelanto del resultado final:",
      "type": "MarkdownBlock"
    },
    {
      "text": "/automata.gif",
      "type": "ImageBlock"
    },
    {
      "text": "Viendo la complejidad que tiene [Lenia](https://es.wikipedia.org/wiki/Lenia) para ser implementado, en este post se experimentar√° espec√≠ficamente haciendo una versi√≥n del juego de la vida m√°s \"suave\" (ya existen btw).",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) > 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n < 1.1) + float(n > 3.9);\\n    if(nowIsDead > 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n > 2.9) * float(n < 3.1);\\n    if(nowIsBorn > 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist < 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i < uStateSize; i++) {\\n    for (let j = 0; j < uStateSize; j++) {\\n      if (random(1) > 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uCircle\\\", uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Las reglas del juego de la vida se pueden encontrar en Wikipedia üóø:\n- Nace: Si una c√©lula muerta tiene exactamente 3 c√©lulas vecinas vivas \"nace\" (es decir, al turno siguiente estar√° viva).\n- Muere: una c√©lula viva puede morir por uno de 2 casos:\n  - Sobrepoblaci√≥n: si tiene m√°s de tres vecinos alrededor.\n  - Aislamiento: si tiene solo un vecino alrededor o ninguno.\n- Vive: una c√©lula se mantiene viva si tiene 2 o 3 vecinos a su alrededor.",
      "type": "MarkdownBlock"
    },
    {
      "text": "# Juego de la vida proporcional",
      "type": "MarkdownBlock"
    },
    {
      "text": "El juego de la vida es algo determinante y el primer experimento es cambiar las reglas a algo m√°s flexible. Las reglas quedar√≠an as√≠:",
      "type": "MarkdownBlock"
    },
    {
      "text": "Siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, 3]`: Vida aumenta en `n/3`.\n- `3 a m√°s`: Vida disminuye en `n/8` (el m√°ximo de `n` es 8).",
      "type": "MarkdownBlock"
    },
    {
      "text": "Para ver la diferencia, se usar√° el siguiente estado inicial:",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) > 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n < 1.1) + float(n > 3.9);\\n    if(nowIsDead > 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n > 2.9) * float(n < 3.1);\\n    if(nowIsBorn > 0.1) isAlive = true;\\n  }\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  const points = 50;\\n  for (let i = 0; i < points; i++) {\\n    const x = 50 * cos((TWO_PI * i) / points);\\n    const y = 50 * sin((TWO_PI * i) / points);\\n    g.point(x, y);\\n  }\\n\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n  frameRate(14);\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Y con las nuevas reglas:",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uGap;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  float live = getState(i, j);\\n  float tl = getState(i - 1, j - 1);\\n  float t = getState(i, j - 1);\\n  float tr = getState(i + 1, j - 1);\\n  float l = getState(i - 1, j);\\n  float r = getState(i + 1, j);\\n  float bl = getState(i - 1, j + 1);\\n  float b = getState(i, j + 1);\\n  float br = getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(n <= 1.0) {\\n    live -= n;\\n  } else if(n <= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / 8.0;\\n  }\\n\\n  gl_FragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\n\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i < points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() => {\\n    restart();\\n  });\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Viene con trucos:\n- Se cambi√≥ el rango de aumentar vida de `[1, 3]` a `[1, 1.5]`. Simplemente porque se ve mejor üëç. Se puede probar otros valores moviendo el slider, representa el `gap` para aumentar la vida. El m√°ximo es 8, lo cual hace que crezca sin parar.\n- Esquinas redondeadas: Suponiendo que la distancia horizontal y vertical es de 1, la vida de las celdas diagonales se multiplic√≥ por `1 / sqrt(2)` (solo se considera la vida proporcionalmente a la distancia horizontal y vertical).",
      "type": "MarkdownBlock"
    },
    {
      "text": "Valores cercanos a 4 (como el del ejemplo) forman patrones rectos.",
      "type": "MarkdownBlock"
    },
    {
      "text": "# Juego de la vida proporcional y zonal",
      "type": "MarkdownBlock"
    },
    {
      "text": "En este experimento se aumentar√° el √°rea considerada para los vecinos. Con ello se tendr√≠an 2 variables `gap` (que representa la formaci√≥n de vida) y `r` (el radio considerado para los vecinos).",
      "type": "MarkdownBlock"
    },
    {
      "text": "Las reglas ahora son, siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, gap]`: Vida aumenta en `n/gap`.\n- `gap a m√°s`: Vida disminuye en `n/totalN`.",
      "type": "MarkdownBlock"
    },
    {
      "text": "No hay una explicaci√≥n \"l√≥gica\" para `totalN`, solo se sigue la corriente de lo que se propuso antes con `1 / sqrt(2)` para las esquinas.",
      "type": "MarkdownBlock"
    },
    {
      "text": "`totalN`: Representa la suma de las distancias proporcionales de los vecinos.",
      "type": "MarkdownBlock"
    },
    {
      "text": "Por ejemplo:\n```glsl\nfloat dist = length(vec2(i, j) - vec2(k, l)); // Distance de la celda evaluada (i, j) al vecino (k, l)\nfloat factor = 1.0 / dist; // Variable propuesta\nfloat curLive = getState(k, l) * factor;\nn += curLive;\ntotalN += factor;\n```",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  float totalN = 0.0;\\n  for(float k = i - uR; k <= i + uR; k++) {\\n    for(float l = j - uR; l <= j + uR; l++) {\\n      if(i == k && j == l) continue;\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float curLive = getState(k, l) * factor;\\n      n += curLive;\\n      totalN += factor;\\n    }\\n  }\\n\\n  if(n <= 1.0) {\\n    live -= n;\\n  } else if(n <= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / totalN;\\n  }\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 3.0, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 4, 1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i < points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() => {\\n    restart();\\n  });\\n  rSlider.input(() => {\\n    restart();\\n  });\\n  restart();\\n\\n  frameRate(4);\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Dos puntos a tener en cuenta:\n- El primer slider es el `gap` de vida y el segundo el radio `r` para considerar vecinos.\n- Se hizo upgrade a la versi√≥n de GLSL para usar las variables de los loops como √≠ndices (no es importante, solo quer√≠a mencionarlo).",
      "type": "MarkdownBlock"
    },
    {
      "text": "# Tunenado el juego de la vida",
      "type": "MarkdownBlock"
    },
    {
      "text": "En el experimente anterior se percibe un cambio dr√°stico entre estados (por eso se redujo a 4 frames por segundo), a este punto solo se busca que se formen patrones m√°s consistentes entre frames (ya ni se aplican las reglas propuestas previamente).",
      "type": "MarkdownBlock"
    },
    {
      "text": "## `live += (uGap - n) * n`",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // :D\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  float change = (uGap - n) * n;\\n  live += change;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 10, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i <= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "- Primer slider: `gap`\n- Segundo slider: Radio para considerar un vecino (`r`). ",
      "type": "MarkdownBlock"
    },
    {
      "text": "Hay muchos sacrilegios tomados para hacer que luzca genial üôÇ. No deber√≠an ser problema, el c√≥digo principal es el siguiente:\n\n```glsl\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  float live = getState(i, j);\n\n  float n = 0.0;\n  for(float r = 1.0; r <= uR; r++) {\n    float points = 8.0 * r;\n    for(float p = 0.0; p < points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 100.0 / dist; // üòâ\n      float klLive = getState(k, l) * factor;\n      n += klLive;\n    }\n  }\n\n  live += (uGap - n) * n;\n\n  fragColor = vec4(vec3(live), 1.0);\n}\n```",
      "type": "MarkdownBlock"
    },
    {
      "text": "El factor tom√≥ un papel importante, reduce el impacto de los vecinos m√°s lejanos. El c√°lculo del nuevo estado se redujo a `live += (uGap - n) * n;`, se omiti√≥ el caso de aislamientos.",
      "type": "MarkdownBlock"
    },
    {
      "text": "Pero parece que no son suficientes cambios para ver una interacci√≥n m√°s suave. Tiene el aspecto que hay mucha probabilidad de sobrevivir, pero el aspecto es m√°s org√°nico.",
      "type": "MarkdownBlock"
    },
    {
      "text": "Con estos resultados se ven 2 oportunidades:\n- Dar m√°s posibilidad de sobrevivir a casos medios.\n- Se puede reducir las reglas a una f√≥rmula para obtener patrones.",
      "type": "MarkdownBlock"
    },
    {
      "text": "Una f√≥rmula que me interes√≥ mucho es la siguiente, da patrones m√°s consistentes.",
      "type": "MarkdownBlock"
    },
    {
      "text": "## `live += -n * log(n) + n * uGap`",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // üòâ\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  live += -n * log(n) + n * uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i <= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Pero los cambios entre estados ahora son m√°s fuerte fuertes (√≥sea se mueve m√°s r√°pido). Por lo que hay que dar m√°s chance a la muerte o reducir el impacto de los vecinos.",
      "type": "MarkdownBlock"
    },
    {
      "text": "# `live += -pow(n - uGap, 2.0) + uGap`",
      "type": "MarkdownBlock"
    },
    {
      "text": "Despu√©s de rebuscar valores que generen patrones org√°nicos, se encontr√≥ que con esta regla se pueden conseguir. Los valores son algo rebuscados pero se consigui√≥ una funci√≥n que representa bien un juego suave:\n- https://www.desmos.com/calculator/hzovhepzko",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 12.9, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i <= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Se dej√≥ el factor en `float factor = 1.0 / dist;` (tiene m√°s sentido) y los par√°metros son los siguientes:\n- `gap`: 12.9\n- `r`: 5",
      "type": "MarkdownBlock"
    },
    {
      "text": "Sin embargo, despu√©s de unas iteraciones el patr√≥n se vuelve ca√≥tico. Aunque, ese inicio es un logro.",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 18, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i <= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "En este ejemplo se renderizan varios puntos aleatorios como estado inicial. Dale play (tanto como gustes üôÇ) para ver distintos patrones.",
      "type": "MarkdownBlock"
    },
    {
      "text": "# Juego de la vida tuneado + colores",
      "type": "MarkdownBlock"
    },
    {
      "text": "√öltimo experimento. Darle un poco de vida con colores. Podr√≠an modificarse las reglas para generar distintos estados dependiendo del color y es justo lo que se muestra a continuaci√≥n:",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i <= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Ahora los patrones son m√°s estables y quedan varias c√©lulas autosuficientes. Los par√°metros son:\n- `gap`: 13\n- Radio `r`: 5",
      "type": "MarkdownBlock"
    },
    {
      "text": "Se tienen 3 dimensiones por celda. Se calculan vecinos por cada dimension, por lo que `n` ahora es un `vec3`. La interacci√≥n en este caso es pasar una dimensi√≥n distinta para el c√°lculo de la celda evaluada:\n\n```glsl\nlive.r += -pow(n.b - uGap, 2.0) + uGap;\nlive.g += -pow(n.r - uGap, 2.0) + uGap;\nlive.b += -pow(n.g - uGap, 2.0) + uGap;\n```",
      "type": "MarkdownBlock"
    },
    {
      "text": "Algo a notar es que hay patrones de expansi√≥n rectos, esto es por el c√°lculo de la vida en la vecindad. Se usan coordenadas polares, se da una vuelta y se va ampliando el radio. El problema est√° en la cantidad de puntos que se eval√∫an por radio, como se muestra:\n\n```glsl\nfloat points = 8.0 * r;\n```",
      "type": "MarkdownBlock"
    },
    {
      "text": "Aumentando la cantidad de puntos por radio requiere buscar otros par√°metros, pero esto mejora en la estabilidad de los patrones:",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 17.5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i <= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "- `gap`: 17.5\n- `r`: 4",
      "type": "MarkdownBlock"
    },
    {
      "text": "Para estabilizar los colores se puede hacer m√°s dependiente a cada dimensi√≥n de las dem√°s, un buen patron encontrado es el siguiente:\n\n```glsl\nlive.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\nlive.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\nlive.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n```",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n  live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n  live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13.4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i <= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uR\\\", r);\\n  myShader.setUniform(\\\"uGap\\\", gap);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Ejec√∫talo varias veces, se obtienen patrones bastante suaves pero hay momentos ca√≥ticos.",
      "type": "MarkdownBlock"
    },
    {
      "text": "---",
      "type": "MarkdownBlock"
    },
    {
      "text": "Nota final:\n\nMuchos de los c√°lculos desde *tunear* son buscados al ojo. Son experimentos para pasar el rato (uno bueno). Si tienes alguna propuesta, feliz de escucharla o probarla!",
      "type": "MarkdownBlock"
    },
    {
      "text": "---",
      "type": "MarkdownBlock"
    },
    {
      "text": "Recursos:\n- [Shaders en corto](/blog/shaders-en-corto)\n- https://es.wikipedia.org/wiki/Juego_de_la_vida",
      "type": "MarkdownBlock"
    },
    {
      "text": "No puedo terminar sin antes recrear el primer ejemplo con el nuevo aut√≥mata creado!",
      "type": "MarkdownBlock"
    },
    {
      "text": "{\"html\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\"></script>\\n    <meta charset=\\\"utf-8\\\" />\\n  </head>\\n  <body>\\n  </body>\\n</html>\\n\",\"js\":\"p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\"webgl2\\\", this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\"experimental-webgl\\\", this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\"Error creating webgl context\\\");\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r <= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p < points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n\\n  vec2 pos = (vXY * 2.0 - 1.0);\\n  pos.x *= (uWidth / uHeight);\\n  float circleDist = length(pos - uCircle);\\n  \\n  if(circleDist < 0.1) {\\n    live = vec3(1.0);\\n  } else {\\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n  }\\n\\n  fragColor = vec4(live, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\n\\nfunction setup() {\\n  createCanvas(350, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i <= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  restart();\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\\n  myShader.setUniform(\\\"uState\\\", g);\\n  myShader.setUniform(\\\"uCircle\\\", uCircle);\\n  myShader.setUniform(\\\"uR\\\", 5);\\n  myShader.setUniform(\\\"uGap\\\", 13.7);\\n  myShader.setUniform(\\\"uWidth\\\", width);\\n  myShader.setUniform(\\\"uHeight\\\", height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\",\"css\":\"html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\"}",
      "type": "LiveCodeBlock"
    },
    {
      "text": "Por esta ocasi√≥n pondr√© todo el c√≥digo aqu√≠ (siempre est√° disponible inspeccionando el iframe), puedes pegarlo y editarlo aqu√≠:\n- https://editor.p5js.org/",
      "type": "MarkdownBlock"
    },
    {
      "text": "```js\np5.RendererGL.prototype._initContext = function () {\n  try {\n    this.drawingContext =\n      this.canvas.getContext(\"webgl2\", this._pInst._glAttributes) ||\n      this.canvas.getContext(\"experimental-webgl\", this._pInst._glAttributes);\n    if (this.drawingContext === null) {\n      throw new Error(\"Error creating webgl context\");\n    } else {\n      const gl = this.drawingContext;\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      this._viewport = this.drawingContext.getParameter(\n        this.drawingContext.VIEWPORT\n      );\n    }\n  } catch (er) {\n    throw er;\n  }\n};\n\nconst vertShader = `#version 300 es\nin vec3 aPosition;\nout vec2 vXY;\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  vXY = pos.xy;\n  pos = pos * 2.0 - 1.0;\n  gl_Position = pos;\n}`;\n\nconst fragShader = `#version 300 es\nprecision mediump float;\nin vec2 vXY;\nuniform float uWidth;\nuniform float uHeight;\nuniform float uR;\nuniform float uLGap;\nuniform float uGap;\nuniform sampler2D uState;\nuniform vec2 uCircle;\nout vec4 fragColor;\nconst float PI = 3.14159264;\n\nvec3 getState(float i, float j) {\n  vec4 data = texture(\n    uState,\n    vec2(\n      (i + 0.5) / uWidth,\n      (j + 0.5) / uHeight\n    )\n  );\n  return data.rgb;\n}\n\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  vec3 live = getState(i, j);\n\n  vec3 n = vec3(0.0);\n  for(float r = 1.0; r <= uR; r++) {\n    float points = 16.0 * r;\n    for(float p = 0.0; p < points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 1.0 / dist;\n      vec3 klLive = getState(k, l) * factor;\n      n.r += klLive.r;\n      n.g += klLive.g;\n      n.b += klLive.b;\n    }\n  }\n\n  vec2 pos = (vXY * 2.0 - 1.0);\n  pos.x *= (uWidth / uHeight);\n  float circleDist = length(pos - uCircle);\n  \n  if(circleDist < 0.1) {\n    live = vec3(1.0);\n  } else {\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n  }\n\n  fragColor = vec4(live, 1.0);\n}\n`;\n\nlet myShader;\nlet g;\n\nfunction setup() {\n  createCanvas(350, 320, WEBGL);\n  g = createGraphics(320, 320, WEBGL);\n  myShader = createShader(vertShader, fragShader);\n\n  g.shader(myShader);\n  g.stroke(255);\n  g.fill(255);\n\n  function restart() {\n    g.background(0);\n\n    const points = 3000;\n    for (let i = 0; i <= points; i++) {\n      const x = width * (random(2) - 1);\n      const y = height * (random(2) - 1);\n      g.stroke(color(random(255), random(255), random(255)));\n      g.point(x, y);\n    }\n\n    imageMode(CENTER);\n    image(g, 0, 0, width, height);\n  }\n\n  restart();\n}\n\nfunction draw() {\n  const angle = frameCount / 80;\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\n  myShader.setUniform(\"uState\", g);\n  myShader.setUniform(\"uCircle\", uCircle);\n  myShader.setUniform(\"uR\", 5);\n  myShader.setUniform(\"uGap\", 13.7);\n  myShader.setUniform(\"uWidth\", width);\n  myShader.setUniform(\"uHeight\", height);\n  g.rect(0, 0, 0, 0);\n  imageMode(CENTER);\n  image(g, 0, 0, width, height);\n}\n```",
      "type": "MarkdownBlock"
    }
  ],
  "isPinned": false
}