<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Transformada discreta de Fourier (DFT) en JavaScript"><meta name="twitter:title" content="Transformada discreta de Fourier (DFT) en JavaScript"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #art #edu"><meta property="og:description" content="Tags: #tech #art #edu"><meta name="twitter:description" content="Tags: #tech #art #edu"><meta property="og:image" content="https://media.giphy.com/media/3BRDkVjKikYW4/giphy.gif"><meta name="twitter:image" content="https://media.giphy.com/media/3BRDkVjKikYW4/giphy.gif"><meta name="generator" content="Astro v5.13.7"><title>Transformada discreta de Fourier (DFT) en JavaScript</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.U4jOVs4w.js"></script><link rel="stylesheet" href="/_astro/index.C9DwYtz5.css">
<style>:root{font-weight:200;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.edit-block{overflow:hidden;border-radius:.25rem;--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
.astro-route-announcer{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media (prefers-reduced-motion){::view-transition-group(*),::view-transition-old(*),::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}
</style>
<link rel="stylesheet" href="/_astro/index.BG8E1MYw.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.Jt7Qpvtv.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-xs font-mono p-2 text-neutral-400 leading-5 break-all"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/transformada-discreta-de-fourier-dft-en-javascript" class="hover:text-white">transformada-discreta-de-fourier-dft-en-javascript</a>  </p>  <div class="flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="72LXe" prefix="s0" component-url="/_astro/PostView.BmyaVLYq.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Transformada discreta de Fourier (DFT) en JavaScript&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;art&quot;],[0,&quot;edu&quot;]]],&quot;creationDate&quot;:[3,&quot;2024-03-22T15:07:34.041Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2025-02-25T20:44:54.197Z&quot;],&quot;isPinned&quot;:[0,true],&quot;container&quot;:[1,[[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Este post explica cómo implementar la *\&quot;Transformada discreta de Fourier\&quot;* (DFT).&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;La implementación está basada en los siguiente recursos:\n\nhttps://www.youtube.com/watch?v=MY4luNgGfms&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;En el video la transformada discreta adelanta los cálculos de la inversa y se ordenan las transformadas por amplitudes. En esta implementación se hará por separado.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Puntos aparte, existen versiones más preparadas de esta implementación como:\n\n- https://www.jezzamon.com/fourier/es.html\n- https://bestiariotopologico.blogspot.com/2020/05/la-orbita-de-homero-simpson-una.html&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Sin embargo, esta implementación está más enfocada en el código.&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = []\\n  const N = X.length\\n  for (let k = 0; k &lt; N; k++) {\\n    let a = 0\\n    let bi = 0\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N\\n      a += X[n] * cos(angle)\\n      bi += -(X[n] * sin(angle))\\n    }\\n    transfumada.push({\\n      a,\\n      bi,\\n    })\\n  }\\n  return transfumada\\n}\\n\\nfunction epicycle(x, y, transfumada, rotation) {\\n  const N = transfumada.length\\n  for (let i = 0; i &lt; N; i++) {\\n    let prevX = x\\n    let prevY = y\\n    let { a, bi } = transfumada[i]\\n    const f = i\\n    const A = sqrt(a ** 2 + bi ** 2)\\n    const hPhase = atan2(bi, a)\\n    x += A * cos(f * time + hPhase + rotation) * 1 / N\\n    y += A * sin(f * time + hPhase + rotation) * 1 / N\\n    let radius = A * 1 / N\\n  }\\n  return createVector(x, y)\\n}\\n\\nlet dataX = []\\nlet dataY = []\\nlet transfumadaX = []\\nlet transfumadaY = []\\nlet time = 0\\n\\nfunction setup() {\\n  createCanvas(320, 320)\\n\\n  const SZ = 100\\n  \\n  const shift = width / 2\\n  const r = width / 3\\n\\n  // head\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(r * cos((i / SZ) * TWO_PI) + shift)\\n    dataY.push(r * sin((i / SZ) * TWO_PI) + shift)\\n  }\\n\\n  // smile\\n  let first = null\\n  for (let i = 0; i &lt; SZ / 2; i++) {\\n    const x = (r/2.5) * cos((i / SZ) * TWO_PI) + shift\\n    const y = (r/2.5) * sin((i / SZ) * TWO_PI) + shift * 1.2\\n    if (!first) first = { x, y }\\n    dataX.push(x)\\n    dataY.push(y)\\n  }\\n  dataX.push(first.x)\\n  dataY.push(first.y)\\n\\n  // eyes: l -&gt; r\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push((r/4) * cos((i / SZ) * TWO_PI) + shift*0.75)\\n    dataY.push((r/4) * sin((i / SZ) * TWO_PI) + shift*0.9)\\n  }\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push((r/4) * cos((i / SZ) * TWO_PI) + shift*1.25)\\n    dataY.push((r/4) * sin((i / SZ) * TWO_PI) + shift*0.9)\\n  }\\n\\n  transfumadaX = dft(dataX)\\n  transfumadaY = dft(dataY)\\n  background(0)\\n}\\n\\nlet prevV = null\\nfunction draw() {\\n  background(&#39;#00000009&#39;)\\n\\n  const vx = epicycle(0, 0, transfumadaX, 0)\\n  const vy = epicycle(vx.x, vx.y, transfumadaY, PI / 2)\\n  const v = createVector(vx.x, vy.y)\\n  \\n  if(prevV !== null) {\\n    stroke(&#39;yellow&#39;)\\n    strokeWeight(3)\\n    line(prevV.x, prevV.y, v.x, v.y)\\n  }\\n  prevV = v\\n\\n  const dt = TWO_PI / transfumadaX.length\\n  time += dt\\n  if (time &gt; TWO_PI) {\\n    prevV = null\\n    time = 0\\n  }\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Empecemos...&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;---&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Transformada&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;La fórmula para la DFT es la siguiente:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;&lt;img\nalt=\&quot;discrete fourier transform\&quot;\nstyle=\&quot;background:white\&quot;\nsrc=\&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/dac5d83db38d0284477c382e26bbc94d167b597b\&quot;\n/&gt;&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;*TRANQUI*, la intención es transformar eso a código. Es complicada, no entiendo a la perfección el funcionamiento (honestidad). Pero, si se divide en partes pequeñas, cobra sentido.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;No se puede explicar de izquierda a derecha, pero sí de adentro hacia afuera.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Iré rápido. Si la intención es dibujar caritas, no veo tan grave saltarse algunas cosas.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;`e**( -(2 * PI * i) / N * k * n)`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Gracias a Euler, esta parte equivale a:\n&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;`cos( (2 * PI * k * n) / N ) - i * sin( (2 * PI * k * n) / N )`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Ahora, esta es una fórmula que trabaja con ángulos. Precisamente es la parte que se repite, por lo que sirve más darle un nombre:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;`const angle = (2 * PI * k * n) / N`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Finalmente se reduce a:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;`cos(angle) - i * sin(angle)`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# IMPORTANTE&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Por qué son necesarios todos estos cálculos? El problema es `i`, es necesario mantenerlo para poder salir del plano complejo. Si no entiendes esto, no te preocupes! es como teletransportarse, llegar de un lugar a otro de una forma inexplicable: `sqrt(-1)`.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Con estos cambios, la fórmula sería equivalente a:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Xk = Σ Xn * (cos(angle) - i * sin(angle))&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;2 cosas en cuenta:\n- Aún no me acerco 100% a código.\n- La Σ sería de 0 a N-1, ya no desde 1, ya que los `arrays` se indexan desde 0.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Si llegaste hasta este punto, puedes sentirte más relajado. Ahora es más sencillo explicar las:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Variables&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;- `X`: Es la serie de datos, en otros términos es un `array` de números.\n- `k`: Es la posición que representa el índice en la transformada.\n- `Xk`: Representa la transformada en `k`.\n- `k`: Es la posición que representa el índice en X (la serie de datos).\n- `Xn`: Es el valor de la serie `X` en la posición `n`.\n- `angle`: Esta parte podría complicar la explicación, de momento es eso, un ángulo.\n- `i`: Es la raíz de -1 y de mis problemas.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Entrada&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;La entrada será la variable `X`. En el código `X[n]` representará a `Xn`.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Salida&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Aquí es donde puede haber confusiones, no se puede llamar `X` a la entrada y a la salida. Se representará los valores de `Xk` con `transform[k]`.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;`transform[k] = Σ X[n] * (cos(angle) - i * sin(angle))`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;---&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Algoritmo&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = []\\n  const N = X.length\\n  for (let k = 0; k &lt; N; k++) {\\n    let a = 0\\n    let bi = 0\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N\\n      a += X[n] * cos(angle)\\n      bi += -(X[n] * sin(angle))\\n    }\\n    const f = k\\n    const A = sqrt(a ** 2 + bi ** 2)\\n    const hPhase = atan2(bi, a)\\n    transfumada.push({\\n      f,\\n      A,\\n      hPhase,\\n    })\\n  }\\n  return transfumada\\n}\\n\\n\\nfunction epicycle(x, y, fourier, rotation) {\\n  const N = fourier.length\\n  for (let i = 0; i &lt; N; i++) {\\n    let prevX = x\\n    let prevY = y\\n    let { A, f, hPhase } = fourier[i]\\n    x += A * cos(f * time + hPhase + rotation) * 1 / N\\n    y += A * sin(f * time + hPhase + rotation) * 1 / N\\n    let radius = A * 1 / N\\n    stroke(\\\&quot;#ffffff50\\\&quot;)\\n    noFill()\\n    ellipse(prevX, prevY, radius * 2)\\n    line(prevX, prevY, x, y)\\n  }\\n  return createVector(x, y)\\n}\\n\\nlet fourierX = []\\nlet fourierY = []\\nlet path = []\\nlet time = 0\\n\\nfunction setup() {\\n  createCanvas(300, 300)\\n\\n  let dataX = []\\n  let dataY = []\\n  const SZ = 200\\n\\n  // head\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(60 * cos((i / SZ) * TWO_PI) + 150)\\n    dataY.push(60 * sin((i / SZ) * TWO_PI) + 150)\\n  }\\n\\n  // smile\\n  let first = null\\n  for (let i = SZ / 2; i &lt; SZ; i++) {\\n    const x = 20 * cos((i / SZ) * TWO_PI) + 150\\n    const y = 20 * sin((i / SZ) * TWO_PI) + 180\\n    if (!first) first = { x, y }\\n    dataX.push(x)\\n    dataY.push(y)\\n  }\\n  dataX.push(first.x)\\n  dataY.push(first.y)\\n\\n  // eyes: l -&gt; r\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 125)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n  }\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 175)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n  }\\n\\n  fourierX = dft(dataX)\\n  fourierY = dft(dataY)\\n  fourierX.sort((a, b) =&gt; b.A - a.A)\\n  fourierY.sort((a, b) =&gt; b.A - a.A)\\n}\\n\\nfunction draw() {\\n  background(0)\\n\\n  const vx = epicycle(0, 0, fourierX, 0)\\n  const vy = epicycle(vx.x, vx.y, fourierY, PI / 2)\\n  const v = createVector(vx.x, vy.y)\\n  path.unshift(v)\\n\\n  beginShape()\\n  stroke(&#39;yellow&#39;)\\n  noFill()\\n  for (let i = 0; i &lt; path.length; i++)\\n    vertex(path[i].x, path[i].y)\\n  endShape()\\n\\n  const dt = (TWO_PI / fourierX.length)\\n  time += dt\\n  if (time &gt; TWO_PI) {\\n    time = 0\\n    path = []\\n  }\\n\\n  fill(&#39;red&#39;)\\n  stroke(&#39;red&#39;)\\n  ellipse(v.x, v.y, 5)\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Empezemos con `angle`:\n\n`const angle = (2 * PI * k * n) / N`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Algo a notar es que `k` y `n` son índices, el código sería el siguiente:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```js\nfunction dft(X) {\n  const N = X.length\n  for (let k = 0; k &lt; N; k++) {\n    for (let n = 0; n &lt; N; n++) {\n      const angle = (2 * PI * k * n) / N\n    }\n  }\n}\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Ahora la parte complicada (compleja 👉 👉). Un número complejo se puede representar de la siguiente forma: `a + bi`, donde `a` es la parte real y `bi` es la parte imaginaria.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Entonces aquí está la magia: Se almacena el producto (la parte imaginaria) en una variable llamada `bi`. Se va suponer que es el producto de `b * i` pero en una sola variable.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```\na = Σ X[n] * cos(angle)\nbi = Σ -(X[n] * sin(angle))\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Este sería el código hasta calcular `a` y `bi`:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```js\nfunction dft(X) {\n  const N = X.length\n  for (let k = 0; k &lt; N; k++) {\n    // a + b*i\n    let a = 0\n    let bi = 0\n    for (let n = 0; n &lt; N; n++) {\n      const angle = (2 * PI * k * n) / N\n      a += X[n] * cos(angle)\n      bi += -(X[n] * sin(angle))\n    }\n  }\n}\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Ahora faltaría almacenar los valores en `transform[k]`. &quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Ya no es necesario el término de la sumatoria `Σ`, ahora está representado por las sumas en segundo bucle:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```js\nfunction dft(X) {\n  const transform = []\n  const N = X.length\n  for (let k = 0; k &lt; N; k++) {\n    // transform[k] = Σ X[n] * cos(angle) - i * sin(angle)\n    // transform[k] = a + b*i\n    let a = 0\n    let bi = 0\n    for (let n = 0; n &lt; N; n++) {\n      const angle = (2 * PI * k * n) / N\n      a += X[n] * cos(angle)\n      bi += -(X[n] * sin(angle))\n    }\n    transform.push({\n      a,\n      bi,\n    })\n  }\n  return transform\n}\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Listo! Eso es *casi* todo.&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = []\\n  const N = X.length\\n  for (let k = 0; k &lt; N; k++) {\\n    // transfumada[k] = Σ X[n] * cos(angle) - i * sin(angle)\\n    // transfumada[k] = a + b*i\\n    let a = 0\\n    let bi = 0\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N\\n      a += X[n] * cos(angle)\\n      bi += -(X[n] * sin(angle))\\n    }\\n    transfumada.push({\\n      a,\\n      bi,\\n    })\\n  }\\n  return transfumada\\n}\\n\\nfunction epicycle(x, y, transfumada, rotation) {\\n  const N = transfumada.length;\\n  const circles = []\\n  for (let k = 0; k &lt; N; k++) {\\n    let prevX = x;\\n    let prevY = y;\\n    let { a, bi } = transfumada[k];\\n    const f = k;\\n    const A = sqrt(a ** 2 + bi ** 2);\\n    const hPhase = atan2(bi, a);\\n    x += (A * cos(f * time + hPhase + rotation) * 1) / N;\\n    y += (A * sin(f * time + hPhase + rotation) * 1) / N;\\n    const radius = (A * 1) / N;\\n    stroke(\\\&quot;#ffffff50\\\&quot;);\\n    noFill();\\n    ellipse(prevX, prevY, radius * 2);\\n    line(prevX, prevY, x, y);\\n  }\\n  return { x, y };\\n}\\n\\nlet fourierX = []\\nlet fourierY = []\\nlet fourierZ = []\\nlet path = []\\nlet pathXY = []\\nlet pathZY = []\\nlet time = 0\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL)\\n\\n  let dataX = []\\n  let dataY = []\\n  let dataZ = []\\n  const SZ = 100\\n\\n  // head\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(60 * cos((i / SZ) * TWO_PI) + 150)\\n    dataY.push(60 * sin((i / SZ) * TWO_PI) + 150)\\n    dataZ.push(100)\\n  }\\n\\n  // smile\\n  let first = null\\n  for (let i = SZ / 2; i &lt; SZ; i++) {\\n    const x = 20 * cos((i / SZ) * TWO_PI) + 150\\n    const y = 20 * sin((i / SZ) * TWO_PI) + 180\\n    if (!first) first = { x, y }\\n    dataX.push(x)\\n    dataY.push(y)\\n    dataZ.push(100)\\n  }\\n  dataX.push(first.x)\\n  dataY.push(first.y)\\n  dataZ.push(100)\\n\\n  // eyes: l -&gt; r\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 125)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n    dataZ.push(100)\\n  }\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 175)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n    dataZ.push(100)\\n  }\\n\\n  fourierX = dft(dataX)\\n  fourierY = dft(dataY)\\n  fourierZ = dft(dataZ)\\n}\\n\\nfunction drawXY() {\\n  const vx = epicycle(0, 0, fourierX, 0)\\n  const vy = epicycle(vx.x, vx.y, fourierY, PI / 2)\\n  const v = createVector(vx.x, vy.y)\\n  line(vx.x, vx.y, v.x, v.y)\\n  line(vy.x, vy.y, v.x, v.y)\\n  fill(&#39;red&#39;)\\n  stroke(&#39;red&#39;)\\n  ellipse(v.x, v.y, 6)\\n  pathXY.unshift(v)\\n  return v\\n}\\n\\nfunction drawZY() {\\n  rotateY(-PI/2);\\n  const vz = epicycle(0, 0, fourierZ, 0)\\n  const vy = epicycle(vz.x, vz.y, fourierY, PI / 2)\\n  const v = createVector(vz.x, vy.y)\\n  line(vz.x, vz.y, v.x, v.y)\\n  line(vy.x, vy.y, v.x, v.y)\\n  fill(&#39;red&#39;)\\n  stroke(&#39;red&#39;)\\n  ellipse(v.x, v.y, 6)\\n  pathZY.unshift(v)\\n  rotateY(PI/2);\\n  return v\\n}\\n\\nfunction drawPath() {\\n  beginShape()\\n  noFill()\\n  stroke(&#39;yellow&#39;)\\n  for(let i = 0; i &lt; path.length; i++) {\\n    const { x, y, z } = path[i]\\n    vertex(x, y, z)\\n  }\\n  endShape()\\n}\\n\\nconst R = 20\\nfunction draw() {\\n  background(0)\\n  translate(0, -80, -300)\\n  rotateY(-PI/4);\\n  \\n  const vxy = drawXY()\\n  const vzy = drawZY()\\n  stroke(255)\\n  \\n  const Ax = vxy.x\\n  const Ay = vxy.y\\n  const Az = vzy.x\\n  const Bx = vzy.x\\n  const By = vzy.y\\n  const Bz = vxy.x\\n  \\n  path.push({\\n    x: Ax,\\n    y: Ay,\\n    z: Az,\\n  })\\n  \\n  translate(0, 0, Az)\\n  point(Ax, Ay)\\n  line(Ax, Ay, 0, Ay)\\n  translate(0, 0, -Az)\\n  \\n  rotateY(-PI/2);\\n  translate(0, 0, -Bz)\\n  line(Bx, By, 0, By)\\n  translate(0, 0, Bz)\\n  rotateY(PI/2);\\n  \\n  drawPath()\\n\\n  const dt = (TWO_PI / fourierX.length)\\n  time += dt\\n  if (time &gt; TWO_PI) {\\n    time = 0\\n    pathXY = []\\n    pathZY = []\\n    path = []\\n  }\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;*Spoiler: Se puede hacer 3d.*&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;---&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Transformada inversa&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;&lt;img\nstyle=\&quot;background:white\&quot;\nalt=\&quot;inverse discrete fourier transform\&quot;\nsrc=\&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/8d45a3d2e50f6f705b31782a1dc0f1e1d0f9c086\&quot;\n/&gt;&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;No se explicará la implementación de esta formula, es prácticamente el mismo procedimiento. Se los dejo de tarea, pero este sería el código:&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```js\nfunction idft(transform) {\n  const iTransform = []\n  const N = transform.length\n  for (let n = 0; n &lt; N; n++) {\n    // X[n] = Σ transform[k] * cos(angle) + i * sin(angle)\n    let x = 0\n    let y = 0\n    for (let k = 0; k &lt; N; k++) {\n      const { a, bi } = transform[k]\n      const f = k\n      const A = sqrt(a ** 2 + bi ** 2)\n      const hPhase = atan2(bi, a)\n      const angle = -f * ((2 * PI * n) / N) + hPhase\n      x += (A * cos(angle)) / N\n      y += (A * sin(angle)) / N\n    }\n    iTransform.push({ x, y })\n  }\n  return iTransform\n}\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Nota&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Si se desea trabajar con varios ejes (y sí se desea) es necesario rotarlo en el eje correspondiente. Lo único necesario sería pasar un parámetro `rotation` a la función `idft` y sumarlo al ángulo:\n\n`const angle = -f * ((2 * PI * n) / N) + hPhase + rotation`&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Simple! 🥲&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;---&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Epicycle&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = []\\n  const N = X.length\\n  for (let k = 0; k &lt; N; k++) {\\n    let a = 0\\n    let bi = 0\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N\\n      a += X[n] * cos(angle)\\n      bi += -(X[n] * sin(angle))\\n    }\\n    const f = k\\n    const A = sqrt(a ** 2 + bi ** 2)\\n    const hPhase = atan2(bi, a)\\n    transfumada.push({\\n      f,\\n      A,\\n      hPhase,\\n    })\\n  }\\n  return transfumada\\n}\\n\\n\\nfunction epicycle(x, y, fourier, rotation) {\\n  const N = fourier.length\\n  for (let i = 0; i &lt; N; i++) {\\n    let prevX = x\\n    let prevY = y\\n    let { A, f, hPhase } = fourier[i]\\n    x += A * cos(f * time + hPhase + rotation) * 1 / N\\n    y += A * sin(f * time + hPhase + rotation) * 1 / N\\n    let radius = A * 1 / N\\n    // Esto dibuja los círculos\\n    stroke(\\\&quot;#ffffff50\\\&quot;)\\n    noFill()\\n    ellipse(prevX, prevY, radius * 2)\\n    line(prevX, prevY, x, y)\\n  }\\n  return createVector(x, y)\\n}\\n\\nlet fourierX = []\\nlet fourierY = []\\nlet path = []\\nlet time = 0\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL)\\n\\n  let dataX = []\\n  let dataY = []\\n  const SZ = 200\\n\\n  // head\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(60 * cos((i / SZ) * TWO_PI) + 150)\\n    dataY.push(60 * sin((i / SZ) * TWO_PI) + 150)\\n  }\\n\\n  // smile\\n  let first = null\\n  for (let i = SZ / 2; i &lt; SZ; i++) {\\n    const x = 20 * cos((i / SZ) * TWO_PI) + 150\\n    const y = 20 * sin((i / SZ) * TWO_PI) + 180\\n    if (!first) first = { x, y }\\n    dataX.push(x)\\n    dataY.push(y)\\n  }\\n  dataX.push(first.x)\\n  dataY.push(first.y)\\n\\n  // eyes: l -&gt; r\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 125)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n  }\\n  for (let i = 0; i &lt; SZ; i++) {\\n    dataX.push(15 * cos((i / SZ) * TWO_PI) + 175)\\n    dataY.push(15 * sin((i / SZ) * TWO_PI) + 140)\\n  }\\n\\n  fourierX = dft(dataX)\\n  fourierY = dft(dataY)\\n  fourierX.sort((a, b) =&gt; b.A - a.A)\\n  fourierY.sort((a, b) =&gt; b.A - a.A)\\n}\\n\\nconst R = 20\\nfunction draw() {\\n  background(0)\\n  translate(0, -60, -500)\\n  const f = frameCount * 0.03\\n  // const x = R * cos(f)\\n  // const z = R * sin(f + 1.5 * PI)\\n  // rotateX(x);\\n  rotateY(f);\\n\\n  const vx = epicycle(0, 0, fourierX, 0)\\n  const vy = epicycle(vx.x, vx.y, fourierY, PI / 2)\\n  const v = createVector(vx.x, vy.y)\\n  path.unshift(v)\\n\\n  beginShape()\\n  stroke(&#39;yellow&#39;)\\n  noFill()\\n  for (let i = 0; i &lt; path.length; i++)\\n    vertex(path[i].x, path[i].y)\\n  endShape()\\n\\n  const dt = (TWO_PI / fourierX.length)\\n  time += dt\\n  if (time &gt; TWO_PI) {\\n    time = 0\\n    path = []\\n  }\\n\\n  fill(&#39;red&#39;)\\n  stroke(&#39;red&#39;)\\n  ellipse(v.x, v.y, 5)\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Así se llaman los círculos que dibujan el rostro. Para lograr esto se tiene que modificar la función inversa (`idft`) para no calcular todo el rostro, solo una parte evaluada e ir trazando cada epiciclo.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;```js\nfunction epicycle(x, y, transform, rotation) {\n  const N = transform.length;\n  for (let k = 0; k &lt; N; k++) {\n    const prevX = x;\n    const prevY = y;\n    const { a, bi } = transform[k];\n    const f = k;\n    const A = sqrt(a ** 2 + bi ** 2);\n    const hPhase = atan2(bi, a);\n    x += (A * cos(f * time + hPhase + rotation)) / N;\n    y += (A * sin(f * time + hPhase + rotation)) / N;\n    // Esto dibuja cada epicycle\n    const radius = A / N;\n    stroke(\&quot;#ffffff50\&quot;);\n    noFill();\n    ellipse(prevX, prevY, radius * 2);\n    line(prevX, prevY, x, y);\n  }\n  return { x, y };\n}\n```&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Es posible tener 4 transformadas, 2 para el plano `XY` y uno para el plano `ZY`. Podría ser cualquiera, pero no voy a mentir que esto explota la mente.&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Puedes mover la perspectiva arrastrando con el mouse/touch, así se pueden percibir mejor las 3 dimensiones.&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = [];\\n  const N = X.length;\\n  for (let k = 0; k &lt; N; k++) {\\n    let a = 0;\\n    let bi = 0;\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N;\\n      a += X[n] * cos(angle);\\n      bi += -(X[n] * sin(angle));\\n    }\\n    const A = sqrt(a ** 2 + bi ** 2);\\n    const hPhase = atan2(bi, a);\\n    transfumada.push({\\n      a,\\n      bi,\\n      f: k,\\n      A,\\n      hPhase,\\n    });\\n  }\\n  return transfumada;\\n}\\n\\nfunction epicycle(x, y, transfumada, rotation) {\\n  const N = transfumada.length;\\n  noFill();\\n  stroke(\\\&quot;#ffffff50\\\&quot;);\\n  for (let i = 0; i &lt; N; i++) {\\n    const prevX = x;\\n    const prevY = y;\\n    const { a, bi, f, A, hPhase } = transfumada[i];\\n    x += (A * cos(f * time + hPhase + rotation)) / N;\\n    y += (A * sin(f * time + hPhase + rotation)) / N;\\n    const radius = A / N;\\n    if (f === 0) continue;\\n    ellipse(prevX, prevY, radius * 2);\\n    line(prevX, prevY, x, y);\\n  }\\n  return { x, y };\\n}\\n\\nlet fourierX = [];\\nlet fourierY = [];\\nlet fourierZ = [];\\nlet path = [];\\nlet time = 0;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n\\n  let dataX = [];\\n  let dataY = [];\\n  let dataZ = [];\\n  const SZ = 200;\\n\\n  const r = 50;\\n  for (let i = 0; i &lt;= SZ; i++) {\\n    const a = r * cos(10 * ((PI * i) / SZ) + PI / 4) + 100;\\n    const b = r * sin(10 * ((PI * i) / SZ) + PI / 4) + 100;\\n    dataX.push(a);\\n    dataY.push((SZ - i) * 1.8 * 0.5);\\n    dataZ.push(b);\\n  }\\n\\n  fourierX = dft(dataX);\\n  fourierY = dft(dataY);\\n  fourierZ = dft(dataZ);\\n\\n  fourierX = fourierX.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n  fourierY = fourierY.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n  fourierZ = fourierZ.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n\\n  // saveGif(&#39;f-3d&#39;, 5);\\n  // ortho();\\n}\\n\\nfunction drawXY() {\\n  const vx = epicycle(0, 0, fourierX, 0);\\n  const vy = epicycle(vx.x, vx.y, fourierY, PI / 2);\\n  const v = createVector(vx.x, vy.y);\\n  line(vx.x, vx.y, v.x, v.y);\\n  line(vy.x, vy.y, v.x, v.y);\\n  return v;\\n}\\n\\nfunction drawZY() {\\n  rotateY(-PI / 2);\\n  const vz = epicycle(0, 0, fourierZ, 0);\\n  const vy = epicycle(vz.x, vz.y, fourierY, PI / 2);\\n  const v = createVector(vz.x, vy.y);\\n  line(vz.x, vz.y, v.x, v.y);\\n  line(vy.x, vy.y, v.x, v.y);\\n  rotateY(PI / 2);\\n  return v;\\n}\\n\\nfunction drawPath() {\\n  beginShape();\\n  noFill();\\n  for (let i = 0; i &lt; path.length; i++) {\\n    const h = Math.floor((360 * i) / fourierX.length);\\n    stroke(`hsl(${h},100%,50%)`);\\n    const { x, y, z } = path[i];\\n    vertex(x, y, z);\\n  }\\n  endShape();\\n}\\n\\nconst R = 20;\\nfunction draw() {\\n  background(0);\\n\\n  orbitControl();\\n  translate(0, -120, -100);\\n  rotateX(-PI / 8);\\n  rotateY(-PI / 4);\\n\\n  const vxy = drawXY();\\n  const vzy = drawZY();\\n  stroke(255);\\n\\n  const Ax = vxy.x;\\n  const Ay = vxy.y;\\n  const Az = vzy.x;\\n\\n  const Bx = vzy.x;\\n  const By = vzy.y;\\n  const Bz = vxy.x;\\n\\n  path.push({\\n    x: Ax,\\n    y: Ay,\\n    z: Az,\\n  });\\n\\n  translate(0, 0, Az);\\n  point(Ax, Ay);\\n  line(Ax, Ay, 0, Ay);\\n  translate(0, 0, -Az);\\n\\n  rotateY(-PI / 2);\\n  translate(0, 0, -Bz);\\n  line(Bx, By, 0, By);\\n  translate(0, 0, Bz);\\n  rotateY(PI / 2);\\n\\n  const dt = TWO_PI / fourierX.length;\\n  time += dt;\\n\\n  // if (time &gt; TWO_PI) {\\n  //   drawPath()\\n  //   noLoop()\\n  //   saveCanvas()\\n  //   return\\n  // }\\n\\n  if (time &gt; TWO_PI) {\\n    time = 0;\\n    path = [];\\n  }\\n\\n  drawPath();\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;]}],[0,{&quot;type&quot;:[0,&quot;GiphyBlock&quot;],&quot;text&quot;:[0,&quot;3BRDkVjKikYW4$%&amp;Peor que probar cosas cuestionables&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;También es posible utilizar sólo 3 transformadas, 2 transformadas se proyectarían en el plano `XY` y 1 en el plano `XZ`.&quot;]}],[0,{&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;],&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const transfumada = [];\\n  const N = X.length;\\n  for (let k = 0; k &lt; N; k++) {\\n    let a = 0;\\n    let bi = 0;\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N;\\n      a += X[n] * cos(angle);\\n      bi += -(X[n] * sin(angle));\\n    }\\n    const A = sqrt(a ** 2 + bi ** 2);\\n    const hPhase = atan2(bi, a);\\n    transfumada.push({\\n      a,\\n      bi,\\n      f: k,\\n      A,\\n      hPhase,\\n    });\\n  }\\n  return transfumada;\\n}\\n\\nfunction epicycle(x, y, transfumada, rotation) {\\n  const N = transfumada.length;\\n  noFill();\\n  stroke(\\\&quot;#fff5\\\&quot;);\\n  for (let i = 0; i &lt; N; i++) {\\n    const prevX = x;\\n    const prevY = y;\\n    const { a, bi, f, A, hPhase } = transfumada[i];\\n    x += (A * cos(f * time + hPhase + rotation)) / N;\\n    y += (A * sin(f * time + hPhase + rotation)) / N;\\n    const radius = A / N;\\n    if (f &gt; 0) {\\n      ellipse(prevX, prevY, radius * 2);\\n    }\\n    line(prevX, prevY, x, y);\\n  }\\n  return { x, y };\\n}\\n\\nlet fourierX = [];\\nlet fourierY = [];\\nlet fourierZ = [];\\nlet path = [];\\nlet time = 0;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n\\n  let dataX = [];\\n  let dataY = [];\\n  let dataZ = [];\\n  const SZ = 200;\\n\\n  const r = 50;\\n  for (let i = 0; i &lt;= SZ; i++) {\\n    const a = r * cos(10 * ((PI * i) / SZ) + PI / 4) + 100;\\n    const b = r * sin(10 * ((PI * i) / SZ) + PI / 4) + 100;\\n    dataX.push(a);\\n    dataY.push((SZ - i) * 1.8 * 0.5);\\n    dataZ.push(b);\\n  }\\n\\n  fourierX = dft(dataX);\\n  fourierY = dft(dataY);\\n  fourierZ = dft(dataZ);\\n\\n  fourierX = fourierX.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n  fourierY = fourierY.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n  fourierZ = fourierZ.toSorted((a, b) =&gt; {\\n    return b.A - a.A;\\n  });\\n}\\n\\nfunction drawXYZ() {\\n  const vx = epicycle(0, 0, fourierX, 0);\\n  const vy = epicycle(vx.x, vx.y, fourierY, PI / 2);\\n  push();\\n  translate(vx.x, vy.y, 0);\\n  rotateX(PI / 2);\\n  const vz = epicycle(0, 0, fourierZ, PI / 2, true);\\n  const v = createVector(vx.x, vy.y, vz.y);\\n  pop();\\n\\n  line(vx.x, vx.y, v.x, v.y);\\n  line(vy.x, vy.y, v.x, v.y);\\n\\n  return v;\\n}\\n\\nfunction drawPath() {\\n  beginShape();\\n  noFill();\\n  for (let i = 0; i &lt; path.length; i++) {\\n    const h = Math.floor((360 * i) / fourierX.length);\\n    stroke(`hsl(${h},100%,50%)`);\\n    const { x, y, z } = path[i];\\n    vertex(x, y, z);\\n  }\\n  endShape();\\n}\\n\\nconst R = 20;\\nfunction draw() {\\n  background(0);\\n\\n  orbitControl();\\n  translate(0, -130, 0);\\n  rotateX(-PI / 4);\\n  rotateY(-PI / 4);\\n\\n  const v = drawXYZ();\\n  stroke(255);\\n\\n  path.push(v);\\n\\n  const dt = TWO_PI / fourierX.length;\\n  time += dt;\\n\\n  if (time &gt; TWO_PI) {\\n    time = 0;\\n    path = [];\\n  }\\n\\n  drawPath();\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Usando el plano complejo&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Es posible ajustar la trayectoria de la transformada para realizar trazos 2D sin la necesidad de realizar 2 transformadas. Para ello la serie tiene que ser de números complejos, en el que la parte real es un eje y la parte imaginaria el otro eje.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El único cambio es en el cálculo de la transformada, ya que en la inversa ya se calcula un eje `y`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\nfunction dft(X) {\n  const fourier = [];\n  const N = X.length;\n  for (let k = 0; k &lt; N; k++) {\n    const Xk = { a: 0, bi: 0, f: k };\n    for (let n = 0; n &lt; N; n++) {\n      const angle = (2 * PI * k * n) / N;\n      const a = X[n].x;\n      const bi = X[n].y;\n      const c = cos(angle);\n      const di = -sin(angle);\n      // FOIL: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n      Xk.a += a * c - bi * di;\n      Xk.bi += a * di + bi * c;\n    }\n    Xk.A = sqrt(Xk.a ** 2 + Xk.bi ** 2);\n    fourier.push(Xk);\n  }\n\n  // Ordenar las amplitudes ayuda a la visualización de los epiciclos\n  fourier.sort((f1, f2) =&gt; f2.A - f1.A);\n\n  return fourier;\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Ejemplo del rostro utilizando una sola transformada:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;function dft(X) {\\n  const fourier = [];\\n  const N = X.length;\\n  for (let k = 0; k &lt; N; k++) {\\n    const Xk = { a: 0, bi: 0, f: k };\\n    for (let n = 0; n &lt; N; n++) {\\n      const angle = (2 * PI * k * n) / N;\\n      const a = X[n].x;\\n      const bi = X[n].y;\\n      const c = cos(angle);\\n      const di = -sin(angle);\\n      // FOIL: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\\n      Xk.a += a * c - bi * di;\\n      Xk.bi += a * di + bi * c;\\n    }\\n    Xk.A = sqrt(Xk.a ** 2 + Xk.bi ** 2);\\n    fourier.push(Xk);\\n  }\\n\\n  fourier.sort((f1, f2) =&gt; f2.A - f1.A);\\n\\n  return fourier;\\n}\\n\\nfunction epicycle(x, y, fourier, rotation) {\\n  const K = fourier.length;\\n  for (let k = 0; k &lt; K; k++) {\\n    let prevX = x;\\n    let prevY = y;\\n    let { a, bi, f } = fourier[k];\\n    const A = sqrt(a ** 2 + bi ** 2);\\n    const hPhase = atan2(bi, a);\\n    x += (A * cos(f * time + hPhase + rotation) * 1) / K;\\n    y += (A * sin(f * time + hPhase + rotation) * 1) / K;\\n    let radius = A / K;\\n    // Esto dibuja los círculos\\n    stroke(\\\&quot;#ffffff50\\\&quot;);\\n    noFill();\\n    ellipse(prevX, prevY, radius * 2);\\n    line(prevX, prevY, x, y);\\n  }\\n  return createVector(x, y);\\n}\\n\\nlet data = [];\\nlet fourier = [];\\nlet path = [];\\nlet time = 0;\\n\\nfunction setup() {\\n  createCanvas(300, 300);\\n\\n  const SZ = 200;\\n\\n  // head\\n  for (let i = 0; i &lt; SZ; i++) {\\n    const x = 60 * cos((i / SZ) * TWO_PI) + 150;\\n    const y = 60 * sin((i / SZ) * TWO_PI) + 150;\\n    data.push({ x, y });\\n  }\\n\\n  // smile\\n  let first = null;\\n  for (let i = SZ / 2; i &lt; SZ; i++) {\\n    const x = 20 * cos((i / SZ) * TWO_PI) + 150;\\n    const y = 20 * sin((i / SZ) * TWO_PI) + 180;\\n    if (!first) first = { x, y };\\n    data.push({ x, y });\\n  }\\n  data.push(first);\\n\\n  // eyes: l -&gt; r\\n  for (let i = 0; i &lt; SZ; i++) {\\n    const x = 15 * cos((i / SZ) * TWO_PI) + 125;\\n    const y = 15 * sin((i / SZ) * TWO_PI) + 140;\\n    data.push({ x, y });\\n  }\\n  for (let i = 0; i &lt; SZ; i++) {\\n    const x = 15 * cos((i / SZ) * TWO_PI) + 175;\\n    const y = 15 * sin((i / SZ) * TWO_PI) + 140;\\n    data.push({ x, y });\\n  }\\n\\n  fourier = dft(data);\\n}\\n\\nfunction draw() {\\n  background(0);\\n\\n  const v = epicycle(0, 0, fourier, 0);\\n  path.unshift(v);\\n\\n  beginShape();\\n  stroke(\\\&quot;yellow\\\&quot;);\\n  noFill();\\n  for (let i = 0; i &lt; path.length; i++) vertex(path[i].x, path[i].y);\\n  endShape();\\n\\n  const dt = TWO_PI / fourier.length;\\n  time += dt;\\n  if (time &gt; TWO_PI) {\\n    time = 0;\\n    path = [];\\n  }\\n\\n  fill(\\\&quot;red\\\&quot;);\\n  stroke(\\\&quot;red\\\&quot;);\\n  ellipse(v.x, v.y, 5);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# FFT&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;*Fast Fourier Transform* permite calcular la transformada con menos operaciones (reduciendo la complejidad de `O(N^2)` a `O(N log(N))`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Un caso específico en el que es útil (que hay miles) es el interactuar con la formula en tiempo real.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;/fft-asset.jpg&quot;],&quot;type&quot;:[0,&quot;ImageBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot; En este ejemplo se pasa una imagen a un dominio de frecuencias y se realiza un *`shift`* para poner las frecuencias más \&quot;relevantes\&quot; al centro. Si solo se consideran las del centro, se obtiene una imagen comprimida (una representación con menos datos).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;html&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.js\\\&quot;&gt;&lt;/script&gt;\\n\\n    &lt;script src=\\\&quot;https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\&quot;,\&quot;js\&quot;:\&quot;let img;\\nlet data;\\nlet fft;\\nlet slider;\\n\\nfunction preload() {\\n  img = loadImage(\\\&quot;/blog/transformada-discreta-de-fourier-dft-en-javascript/img/fft-asset.jpg\\\&quot;);\\n}\\n\\nfunction setup() {\\n  createCanvas(320, 320);\\n  slider = createSlider(1, 80, 25, 1);\\n  slider.id(\\\&quot;slider\\\&quot;);\\n  slider.position(10, 10);\\n\\n  image(img, width / 2, 0, width / 2, height / 2);\\n  data = [];\\n  for (let r = 0; r &lt; height / 2; r++) {\\n    data.push([]);\\n    for (let c = width / 2; c &lt; width; c++) {\\n      const x = c;\\n      const y = r;\\n      const pixel = get(x, y);\\n      const R = red(pixel);\\n      const G = green(pixel);\\n      const B = blue(pixel);\\n      const v = round((R + G + B) / 3);\\n      data[r].push([v, 0]);\\n      set(x, y, v);\\n    }\\n  }\\n\\n  data = nj.array(data);\\n  fft = nj.fft(data);\\n\\n  for (let r = 0; r &lt; height / 2; r++) {\\n    for (let c = 0; c &lt; width / 2; c++) {\\n      let k = r;\\n      let l = c - width / 2;\\n      l = (l + height / 4) % (height / 2);\\n      k = (k + width / 4) % (width / 2);\\n      const a = fft.get(k, l, 0);\\n      const bi = fft.get(k, l, 1);\\n      const v = mod(a, bi);\\n      const x = c;\\n      const y = r;\\n      set(x, y, v);\\n    }\\n  }\\n}\\n\\nfunction mod(a, bi) {\\n  return sqrt(a ** 2 + bi ** 2) / 200;\\n}\\n\\nlet prevMaxD = -1;\\nfunction draw() {\\n  const maxD = slider.value();\\n  if (maxD === prevMaxD) return;\\n  prevMaxD = maxD;\\n\\n  const [imgH, imgW] = data.shape;\\n\\n  let M = new Array(imgH).fill(0).map((r) =&gt; new Array(imgW));\\n  const cx = imgW / 2;\\n  const cy = imgH / 2;\\n  for (let r = 0; r &lt; imgH; r++) {\\n    for (let c = 0; c &lt; imgW; c++) {\\n      const k = (c + width / 4) % (width / 2);\\n      const l = (r + height / 4) % (height / 2);\\n      const d = sqrt((k - cx) ** 2 + (l - cy) ** 2);\\n      if (d &lt; maxD) M[r][c] = [1, 1];\\n      else M[r][c] = [0, 0];\\n    }\\n  }\\n  M = nj.array(M);\\n  const fftM = fft.multiply(M);\\n\\n  for (let r = height / 2; r &lt; height; r++) {\\n    for (let c = 0; c &lt; width / 2; c++) {\\n      let k = r - height / 2;\\n      let l = c;\\n      l = (l + height / 4) % (height / 2);\\n      k = (k + width / 4) % (width / 2);\\n      const a = fftM.get(k, l, 0);\\n      const bi = fftM.get(k, l, 1);\\n      const v = mod(a, bi);\\n      const x = c;\\n      const y = r;\\n      set(x, y, v);\\n    }\\n  }\\n\\n  const out = nj.ifft(fftM);\\n\\n  for (let r = height / 2; r &lt; height; r++) {\\n    for (let c = width / 2; c &lt; width; c++) {\\n      const n = r - height / 2;\\n      const m = c - width / 2;\\n      const v = out.get(n, m, 0);\\n      const x = c;\\n      const y = r;\\n      set(x, y, v);\\n    }\\n  }\\n\\n  updatePixels();\\n\\n  noFill();\\n  stroke(255);\\n  circle(width/4, 3*height/4, maxD*2);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  display: flex;\\n  min-height: 100vh;\\n  align-items: center;\\n  justify-content: center;\\n}\\ncanvas {\\n  display: block;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El algoritmo de la `FFT` tiene una implementación diferente, en este ejemplo se usó la de:\n- https://github.com/nicolaspanel/numjs/?tab=readme-ov-file#fast-fourier-transform-fft&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;---&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;# Fin&quot;]}],[0,{&quot;type&quot;:[0,&quot;MarkdownBlock&quot;],&quot;text&quot;:[0,&quot;Al principio buscaba implementaciones para entenderla, pero no lo logré hasta tratar directamente con la fórmula. Lo cierto es que la expresión resume bastante todos los cálculos, así son las mates.&quot;]}]]],&quot;slugUrl&quot;:[0,&quot;transformada-discreta-de-fourier-dft-en-javascript&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Marzo 22, 2024</div><p class="text-neutral-400 text-xs flex gap-1">6 minutos de lectura </p></div><h1>Transformada discreta de Fourier (DFT) en JavaScript</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">Índice:</h2><div><!----><ul><!--[--><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#transformada" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Transformada"><p>Transformada</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#importante" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="IMPORTANTE"><p>IMPORTANTE</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#xk-xn-cosangle-i-sinangle" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Xk = Σ Xn * (cos(angle) - i * sin(angle))"><p>Xk = Σ Xn * (cos(angle) - i * sin(angle))</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#variables" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Variables"><p>Variables</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#entrada" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Entrada"><p>Entrada</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#salida" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Salida"><p>Salida</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#algoritmo" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Algoritmo"><p>Algoritmo</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#transformada-inversa" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Transformada inversa"><p>Transformada inversa</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#nota" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Nota"><p>Nota</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#epicycle" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Epicycle"><p>Epicycle</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#usando-el-plano-complejo" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Usando el plano complejo"><p>Usando el plano complejo</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#fft" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="FFT"><p>FFT</p>
</a><!----></li><li><a href="/blog/transformada-discreta-de-fourier-dft-en-javascript/#fin" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Fin"><p>Fin</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Este post explica cómo implementar la <em>&quot;Transformada discreta de Fourier&quot;</em> (DFT).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>La implementación está basada en los siguiente recursos:</p>
<p><a href="https://www.youtube.com/watch?v=MY4luNgGfms" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://www.youtube.com/watch?v=MY4luNgGfms</a></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>En el video la transformada discreta adelanta los cálculos de la inversa y se ordenan las transformadas por amplitudes. En esta implementación se hará por separado.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Puntos aparte, existen versiones más preparadas de esta implementación como:</p>
<ul>
<li><a href="https://www.jezzamon.com/fourier/es.html" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://www.jezzamon.com/fourier/es.html</a></li>
<li><a href="https://bestiariotopologico.blogspot.com/2020/05/la-orbita-de-homero-simpson-una.html" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://bestiariotopologico.blogspot.com/2020/05/la-orbita-de-homero-simpson-una.html</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Sin embargo, esta implementación está más enfocada en el código.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Empecemos...</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="transformada">Transformada</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>La fórmula para la DFT es la siguiente:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><img
alt="discrete fourier transform"
style="background:white"
src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dac5d83db38d0284477c382e26bbc94d167b597b"
/></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><em>TRANQUI</em>, la intención es transformar eso a código. Es complicada, no entiendo a la perfección el funcionamiento (honestidad). Pero, si se divide en partes pequeñas, cobra sentido.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>No se puede explicar de izquierda a derecha, pero sí de adentro hacia afuera.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Iré rápido. Si la intención es dibujar caritas, no veo tan grave saltarse algunas cosas.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><code>e**( -(2 * PI * i) / N * k * n)</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Gracias a Euler, esta parte equivale a:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><code>cos( (2 * PI * k * n) / N ) - i * sin( (2 * PI * k * n) / N )</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Ahora, esta es una fórmula que trabaja con ángulos. Precisamente es la parte que se repite, por lo que sirve más darle un nombre:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><code>const angle = (2 * PI * k * n) / N</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Finalmente se reduce a:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><code>cos(angle) - i * sin(angle)</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="importante">IMPORTANTE</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Por qué son necesarios todos estos cálculos? El problema es <code>i</code>, es necesario mantenerlo para poder salir del plano complejo. Si no entiendes esto, no te preocupes! es como teletransportarse, llegar de un lugar a otro de una forma inexplicable: <code>sqrt(-1)</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Con estos cambios, la fórmula sería equivalente a:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="xk-xn-cosangle-i-sinangle">Xk = Σ Xn * (cos(angle) - i * sin(angle))</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>2 cosas en cuenta:</p>
<ul>
<li>Aún no me acerco 100% a código.</li>
<li>La Σ sería de 0 a N-1, ya no desde 1, ya que los <code>arrays</code> se indexan desde 0.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Si llegaste hasta este punto, puedes sentirte más relajado. Ahora es más sencillo explicar las:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="variables">Variables</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><ul>
<li><code>X</code>: Es la serie de datos, en otros términos es un <code>array</code> de números.</li>
<li><code>k</code>: Es la posición que representa el índice en la transformada.</li>
<li><code>Xk</code>: Representa la transformada en <code>k</code>.</li>
<li><code>k</code>: Es la posición que representa el índice en X (la serie de datos).</li>
<li><code>Xn</code>: Es el valor de la serie <code>X</code> en la posición <code>n</code>.</li>
<li><code>angle</code>: Esta parte podría complicar la explicación, de momento es eso, un ángulo.</li>
<li><code>i</code>: Es la raíz de -1 y de mis problemas.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="entrada">Entrada</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>La entrada será la variable <code>X</code>. En el código <code>X[n]</code> representará a <code>Xn</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="salida">Salida</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Aquí es donde puede haber confusiones, no se puede llamar <code>X</code> a la entrada y a la salida. Se representará los valores de <code>Xk</code> con <code>transform[k]</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><code>transform[k] = Σ X[n] * (cos(angle) - i * sin(angle))</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="algoritmo">Algoritmo</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Empezemos con <code>angle</code>:</p>
<p><code>const angle = (2 * PI * k * n) / N</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Algo a notar es que <code>k</code> y <code>n</code> son índices, el código sería el siguiente:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dft</span>(<span class="hljs-params">X</span>) {
  <span class="hljs-keyword">const</span> N = X.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; N; n++) {
      <span class="hljs-keyword">const</span> angle = (<span class="hljs-number">2</span> * <span class="hljs-variable constant_">PI</span> * k * n) / N
    }
  }
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Ahora la parte complicada (compleja 👉 👉). Un número complejo se puede representar de la siguiente forma: <code>a + bi</code>, donde <code>a</code> es la parte real y <code>bi</code> es la parte imaginaria.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Entonces aquí está la magia: Se almacena el producto (la parte imaginaria) en una variable llamada <code>bi</code>. Se va suponer que es el producto de <code>b * i</code> pero en una sola variable.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code>a = Σ X[n] * cos(angle)
bi = Σ -(X[n] * sin(angle))
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Este sería el código hasta calcular <code>a</code> y <code>bi</code>:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dft</span>(<span class="hljs-params">X</span>) {
  <span class="hljs-keyword">const</span> N = X.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
    <span class="hljs-comment">// a + b*i</span>
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> bi = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; N; n++) {
      <span class="hljs-keyword">const</span> angle = (<span class="hljs-number">2</span> * <span class="hljs-variable constant_">PI</span> * k * n) / N
      a += X[n] * <span class="hljs-title function_">cos</span>(angle)
      bi += -(X[n] * <span class="hljs-title function_">sin</span>(angle))
    }
  }
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Ahora faltaría almacenar los valores en <code>transform[k]</code>. </p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Ya no es necesario el término de la sumatoria <code>Σ</code>, ahora está representado por las sumas en segundo bucle:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dft</span>(<span class="hljs-params">X</span>) {
  <span class="hljs-keyword">const</span> transform = []
  <span class="hljs-keyword">const</span> N = X.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
    <span class="hljs-comment">// transform[k] = Σ X[n] * cos(angle) - i * sin(angle)</span>
    <span class="hljs-comment">// transform[k] = a + b*i</span>
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> bi = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; N; n++) {
      <span class="hljs-keyword">const</span> angle = (<span class="hljs-number">2</span> * <span class="hljs-variable constant_">PI</span> * k * n) / N
      a += X[n] * <span class="hljs-title function_">cos</span>(angle)
      bi += -(X[n] * <span class="hljs-title function_">sin</span>(angle))
    }
    transform.<span class="hljs-title function_">push</span>({
      a,
      bi,
    })
  }
  <span class="hljs-keyword">return</span> transform
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Listo! Eso es <em>casi</em> todo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><em>Spoiler: Se puede hacer 3d.</em></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="transformada-inversa">Transformada inversa</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><img
style="background:white"
alt="inverse discrete fourier transform"
src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d45a3d2e50f6f705b31782a1dc0f1e1d0f9c086"
/></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>No se explicará la implementación de esta formula, es prácticamente el mismo procedimiento. Se los dejo de tarea, pero este sería el código:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">idft</span>(<span class="hljs-params">transform</span>) {
  <span class="hljs-keyword">const</span> iTransform = []
  <span class="hljs-keyword">const</span> N = transform.<span class="hljs-property">length</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; N; n++) {
    <span class="hljs-comment">// X[n] = Σ transform[k] * cos(angle) + i * sin(angle)</span>
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> y = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
      <span class="hljs-keyword">const</span> { a, bi } = transform[k]
      <span class="hljs-keyword">const</span> f = k
      <span class="hljs-keyword">const</span> A = <span class="hljs-title function_">sqrt</span>(a ** <span class="hljs-number">2</span> + bi ** <span class="hljs-number">2</span>)
      <span class="hljs-keyword">const</span> hPhase = <span class="hljs-title function_">atan2</span>(bi, a)
      <span class="hljs-keyword">const</span> angle = -f * ((<span class="hljs-number">2</span> * <span class="hljs-variable constant_">PI</span> * n) / N) + hPhase
      x += (A * <span class="hljs-title function_">cos</span>(angle)) / N
      y += (A * <span class="hljs-title function_">sin</span>(angle)) / N
    }
    iTransform.<span class="hljs-title function_">push</span>({ x, y })
  }
  <span class="hljs-keyword">return</span> iTransform
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="nota">Nota</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Si se desea trabajar con varios ejes (y sí se desea) es necesario rotarlo en el eje correspondiente. Lo único necesario sería pasar un parámetro <code>rotation</code> a la función <code>idft</code> y sumarlo al ángulo:</p>
<p><code>const angle = -f * ((2 * PI * n) / N) + hPhase + rotation</code></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Simple! 🥲</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="epicycle">Epicycle</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Así se llaman los círculos que dibujan el rostro. Para lograr esto se tiene que modificar la función inversa (<code>idft</code>) para no calcular todo el rostro, solo una parte evaluada e ir trazando cada epiciclo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">epicycle</span>(<span class="hljs-params">x, y, transform, rotation</span>) {
  <span class="hljs-keyword">const</span> N = transform.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
    <span class="hljs-keyword">const</span> prevX = x;
    <span class="hljs-keyword">const</span> prevY = y;
    <span class="hljs-keyword">const</span> { a, bi } = transform[k];
    <span class="hljs-keyword">const</span> f = k;
    <span class="hljs-keyword">const</span> A = <span class="hljs-title function_">sqrt</span>(a ** <span class="hljs-number">2</span> + bi ** <span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> hPhase = <span class="hljs-title function_">atan2</span>(bi, a);
    x += (A * <span class="hljs-title function_">cos</span>(f * time + hPhase + rotation)) / N;
    y += (A * <span class="hljs-title function_">sin</span>(f * time + hPhase + rotation)) / N;
    <span class="hljs-comment">// Esto dibuja cada epicycle</span>
    <span class="hljs-keyword">const</span> radius = A / N;
    <span class="hljs-title function_">stroke</span>(<span class="hljs-string">&quot;#ffffff50&quot;</span>);
    <span class="hljs-title function_">noFill</span>();
    <span class="hljs-title function_">ellipse</span>(prevX, prevY, radius * <span class="hljs-number">2</span>);
    <span class="hljs-title function_">line</span>(prevX, prevY, x, y);
  }
  <span class="hljs-keyword">return</span> { x, y };
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Es posible tener 4 transformadas, 2 para el plano <code>XY</code> y uno para el plano <code>ZY</code>. Podría ser cualquiera, pero no voy a mentir que esto explota la mente.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Puedes mover la perspectiva arrastrando con el mouse/touch, así se pueden percibir mejor las 3 dimensiones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><div class="relative flex place-items-center bg-black bg-opacity-30"><img loading="lazy" class="m-auto w-auto h-80 object-cover" src="https://media.giphy.com/media/3BRDkVjKikYW4/giphy.gif" alt="gif-block"><div class="absolute top-0 left-0 right-0 bottom-0 bg-[#333a]"></div><div class="flex absolute w-full h-full"><p class="font-sans m-auto p-4 text-center text-2xl font-bold">Peor que probar cosas cuestionables</p></div></div><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>También es posible utilizar sólo 3 transformadas, 2 transformadas se proyectarían en el plano <code>XY</code> y 1 en el plano <code>XZ</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="usando-el-plano-complejo">Usando el plano complejo</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Es posible ajustar la trayectoria de la transformada para realizar trazos 2D sin la necesidad de realizar 2 transformadas. Para ello la serie tiene que ser de números complejos, en el que la parte real es un eje y la parte imaginaria el otro eje.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>El único cambio es en el cálculo de la transformada, ya que en la inversa ya se calcula un eje <code>y</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dft</span>(<span class="hljs-params">X</span>) {
  <span class="hljs-keyword">const</span> fourier = [];
  <span class="hljs-keyword">const</span> N = X.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; N; k++) {
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Xk</span> = { <span class="hljs-attr">a</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">bi</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">f</span>: k };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; N; n++) {
      <span class="hljs-keyword">const</span> angle = (<span class="hljs-number">2</span> * <span class="hljs-variable constant_">PI</span> * k * n) / N;
      <span class="hljs-keyword">const</span> a = X[n].<span class="hljs-property">x</span>;
      <span class="hljs-keyword">const</span> bi = X[n].<span class="hljs-property">y</span>;
      <span class="hljs-keyword">const</span> c = <span class="hljs-title function_">cos</span>(angle);
      <span class="hljs-keyword">const</span> di = -<span class="hljs-title function_">sin</span>(angle);
      <span class="hljs-comment">// FOIL: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i</span>
      <span class="hljs-title class_">Xk</span>.<span class="hljs-property">a</span> += a * c - bi * di;
      <span class="hljs-title class_">Xk</span>.<span class="hljs-property">bi</span> += a * di + bi * c;
    }
    <span class="hljs-title class_">Xk</span>.<span class="hljs-property">A</span> = <span class="hljs-title function_">sqrt</span>(<span class="hljs-title class_">Xk</span>.<span class="hljs-property">a</span> ** <span class="hljs-number">2</span> + <span class="hljs-title class_">Xk</span>.<span class="hljs-property">bi</span> ** <span class="hljs-number">2</span>);
    fourier.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Xk</span>);
  }

  <span class="hljs-comment">// Ordenar las amplitudes ayuda a la visualización de los epiciclos</span>
  fourier.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">f1, f2</span>) =&gt;</span> f2.<span class="hljs-property">A</span> - f1.<span class="hljs-property">A</span>);

  <span class="hljs-keyword">return</span> fourier;
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Ejemplo del rostro utilizando una sola transformada:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="fft">FFT</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p><em>Fast Fourier Transform</em> permite calcular la transformada con menos operaciones (reduciendo la complejidad de <code>O(N^2)</code> a <code>O(N log(N))</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Un caso específico en el que es útil (que hay miles) es el interactuar con la formula en tiempo real.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex flex-col w-full"><img loading="lazy" class="w-auto h-80 object-contain bg-black bg-opacity-30" src="/blog/transformada-discreta-de-fourier-dft-en-javascript/img/fft-asset.jpg"><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p> En este ejemplo se pasa una imagen a un dominio de frecuencias y se realiza un <em><code>shift</code></em> para poner las frecuencias más &quot;relevantes&quot; al centro. Si solo se consideran las del centro, se obtiene una imagen comprimida (una representación con menos datos).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>El algoritmo de la <code>FFT</code> tiene una implementación diferente, en este ejemplo se usó la de:</p>
<ul>
<li><a href="https://github.com/nicolaspanel/numjs/?tab=readme-ov-file#fast-fourier-transform-fft" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://github.com/nicolaspanel/numjs/?tab=readme-ov-file#fast-fourier-transform-fft</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><h1 class="font-mono" id="fin">Fin</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="transformada-discreta-de-fourier-dft-en-javascript"><div class="font-sans w-full"><p>Al principio buscaba implementaciones para entenderla, pero no lo logré hasta tratar directamente con la fórmula. Lo cierto es que la expresión resume bastante todos los cálculos, así son las mates.</p>
</div></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html> 