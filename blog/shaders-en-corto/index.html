<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Shaders en corto"><meta name="twitter:title" content="Shaders en corto"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #edu #art"><meta property="og:description" content="Tags: #tech #edu #art"><meta name="twitter:description" content="Tags: #tech #edu #art"><meta property="og:image" content="https://moloxe.github.io/_astro/generic.DwdIj1sk.jpg"><meta name="twitter:image" content="https://moloxe.github.io/_astro/generic.DwdIj1sk.jpg"><meta name="generator" content="Astro v5.13.7"><title>Shaders en corto</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.U4jOVs4w.js"></script><link rel="stylesheet" href="/_astro/index.C9DwYtz5.css">
<style>:root{font-weight:200;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.edit-block{overflow:hidden;border-radius:.25rem;--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
.astro-route-announcer{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media (prefers-reduced-motion){::view-transition-group(*),::view-transition-old(*),::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}
</style>
<link rel="stylesheet" href="/_astro/index.BG8E1MYw.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.Jt7Qpvtv.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-xs font-mono p-2 text-neutral-400 leading-5 break-all"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/shaders-en-corto" class="hover:text-white">shaders-en-corto</a>  </p>  <div class="flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="ZOvEXx" prefix="s0" component-url="/_astro/PostView.BmyaVLYq.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Shaders en corto&quot;],&quot;creationDate&quot;:[3,&quot;2024-05-07T18:01:21.031Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2024-11-19T16:50:33.247Z&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;edu&quot;],[0,&quot;art&quot;]]],&quot;container&quot;:[1,[[0,{&quot;text&quot;:[0,&quot;Hola! esta vez intentaré plasmar lo que aprendí sobre shaders. Se implementarán algunos temas en el contexto de shaders. Con un poco de fe, espero sirva.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Los shaders se aplican sobre objetos 3D, por lo que es necesario contar con uno antes de usarlos (spoiler: solo se usa un cuadrado).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Shaders&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Los shaders son una forma especial de renderizar gráficos. A diferencia de mostrar un círculo en una pantalla (con algún lenguaje de programación), el equivalente en shaders sería saber si una coordenada pertenece a ese círculo y determinar que color asignarle.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Hay muchas suposiciones incompletas en esa definición, pero, es suficiente para saber que no son una forma tradicional de programar con gráficos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## GLSL + P5js&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;GLSL es el lenguaje de programación para shaders. El cómo se comunica un shader con un programa depende mucho de la plataforma. P5js es una librería que facilita trabajar con shaders en el navegador usando WEBGL.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- Vertex shader: Define dónde renderizar el vértice evaluado\n- Fragment shader: Define el color a renderizar cuando se evalúa una coordenada respecto al objeto.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### Vertex shaders&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;P5js ofrece la propiedad `aPosition` como coordenadas del vértice.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En P5js los vértices están en el rango de [0, 1] y para renderizarlo como se \&quot;espera\&quot;, es necesario escalarlo a un rango entre [-1, 1].&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para definir la posición del vértice, se tiene que asignar un vector a `gl_Position`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```glsl\n// shader.vert\nattribute vec3 aPosition;\n\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  pos = pos * 2.0 - 1.0;\n  gl_Position = pos;\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### Fragment shaders&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para definir el color a renderizar, se tiene que asignar un vector (que representa un color) a `gl_FragColor`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```glsl\n// shader.frag\nprecision mediump float;\n\nvoid main() {\n  gl_FragColor = vec4(1.0, 0, 0, 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;*Nota: GLSL es estricto con el uso de coma flotante (`float`), además, es necesario definir la precisión.*&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Sketch P5js&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para cargar un shader en P5js, es necesario especificar que se usará WEBGL al crear el canvas.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\nlet myShader;\n\nfunction preload() {\n  myShader = loadShader(\&quot;shader.vert\&quot;, \&quot;shader.frag\&quot;);\n}\n\nfunction setup() {\n  createCanvas(320, 320, WEBGL);\n}\n\nfunction draw() {\n  background(0);\n  shader(myShader);\n  rect(0, 0, 0, 0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;*Nota: El `rect` se define con un tamaño 0. Esto es algo específico de P5js (con algunas figuras en 2D), cuando se carga un shader este ignora los parámetros definidos. Sin embargo, si se respetan las proporciones de los vértices.*&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\n\\nvoid main() {\\n  gl_FragColor = vec4(1.0, 0, 0, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para probarlo es posible cargar los shaders en `createShader` como strings.\n\nCopia y pega lo siguiente en:\nhttps://editor.p5js.org/&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\nconst vertShader = `\nattribute vec3 aPosition;\n\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  pos = pos * 2.0 - 1.0;\n  gl_Position = pos;\n}\n\n`;\n\nconst fragShader = `\nprecision mediump float;\n\nvoid main() {\n  gl_FragColor = vec4(1.0, 0, 0, 1.0);\n}\n`;\n\nlet myShader;\nfunction setup() {\n  myShader = createShader(vertShader, fragShader);\n  createCanvas(320, 320, WEBGL);\n}\n\nfunction draw() {\n  background(0);\n  shader(myShader);\n  rect(0, 0, 0, 0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se usará este sketch como referencia en los siguientes ejemplos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Esencial&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Círculos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  float radius = 0.5;\\n  vec2 circle1 = vec2(-0.5, -0.5);\\n  vec2 circle2 = vec2(0.5, 0.5);\\n\\n  float color = min(\\n    step(radius, length(vXY - circle1.xy)),\\n    step(radius, length(vXY - circle2.xy))\\n  );\\n\\n  color = 1.0 - color;\\n  gl_FragColor = vec4(vec3(color), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para determinar un color en función de la posición, es necesario comunicar al `fragment shader` la posición. Esto es posible definiendo variables las cuales pueden compartir ambos `vertex shader` y `fragment shader`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```glsl\n// shader.vert\nattribute vec3 aPosition;\nvarying vec2 vXY; // VARIABLE COMPARTIDA\n\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  pos = pos * 2.0 - 1.0;\n  vXY = pos.xy;\n  gl_Position = pos;\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Luego se puede recibir desde el `fragment shader` la variable `vXY`:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```glsl\n// shader.frag\nprecision mediump float;\nvarying vec2 vXY; // VARIABLE COMPARTIDA\n\nvoid main() {\n  float radius = 0.5;\n  vec2 circle1 = vec2(-0.5, -0.5);\n  vec2 circle2 = vec2(0.5, 0.5);\n\n  float color = min(\n    step(radius, length(vXY - circle1.xy)),\n    step(radius, length(vXY - circle2.xy))\n  );\n\n  color = 1.0 - color;\n  gl_FragColor = vec4(vec3(color), 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Explicación: Para determinar el color, primero se calcula la distancia a alguno de los círculos. Con la función `length` se puede obtener la distancia euclidiana al origen, en este caso se suma para hacer una traslación respecto al punto evaluado. Luego `step` devuelve `1` si la distancia es mayor a `radius`, por ese motivo se invierte el color antes de definirlo.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Cuadrados&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  float size1 = 0.5;\\n  vec2 square1 = vec2(0.5, 0.5);\\n  float size2 = 0.25;\\n  vec2 square2 = vec2(-0.5, -0.5);\\n  float x = vXY.x;\\n  float y = vXY.y;\\n  float color = min((\\n      step(size1, abs(square1.x - x)) +\\n      step(size1, abs(square1.y - y))\\n    ), (\\n      step(size2, abs(square2.x - x)) +\\n      step(size2, abs(square2.y - y))\\n  ));\\n  color = 1.0 - color;\\n  gl_FragColor = vec4(vec3(color), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```glsl\nprecision mediump float;\nvarying vec2 vXY;\n\nvoid main() {\n  float size1 = 0.5;\n  vec2 square1 = vec2(0.5, 0.5);\n  float size2 = 0.25;\n  vec2 square2 = vec2(-0.5, -0.5);\n  float x = vXY.x;\n  float y = vXY.y;\n  float color = min((\n      step(size1, abs(square1.x - x)) +\n      step(size1, abs(square1.y - y))\n    ), (\n      step(size2, abs(square2.x - x)) +\n      step(size2, abs(square2.y - y))\n  ));\n  color = 1.0 - color;\n  gl_FragColor = vec4(vec3(color), 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Explicación: A diferencia del círculo, los cuadrados se pueden determinar con una distancia `manhattan` que sería simplemente sumar si se encuentra en el rango del eje `x` con si se encuentra en el eje `y`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Movimiento&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform vec3 uCircle;\\n\\nvoid main() {\\n  float radius = uCircle.z;\\n  float color = step(radius, length(vXY - uCircle.xy));\\n  color = 1.0 - color;\\n  gl_FragColor = vec4(vec3(color), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  const angle = (TWO_PI * (frameCount % 200)) / 200;\\n  const x = 0.5 * cos(angle);\\n  const y = 0.5 * sin(angle);\\n  background(0);\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, [x, y, 0.5]);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para compartir variables desde JS a los shaders, se utilizan los `uniform`. En este ejemplo se comparte la posición y el radio como un `vec3`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\nconst vertShader = `\nattribute vec3 aPosition;\nvarying vec2 vXY;\n\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  pos = pos * 2.0 - 1.0;\n  vXY = pos.xy;\n  gl_Position = pos;\n}\n\n`;\n\nconst fragShader = `\nprecision mediump float;\nvarying vec2 vXY;\nuniform vec3 uCircle;\n\nvoid main() {\n  float radius = uCircle.z;\n  float color = step(radius, length(vXY - uCircle.xy));\n  color = 1.0 - color;\n  gl_FragColor = vec4(vec3(color), 1.0);\n}\n`;\n\nlet myShader;\nfunction setup() {\n  myShader = createShader(vertShader, fragShader);\n  createCanvas(320, 320, WEBGL);\n}\n\nfunction draw() {\n  const angle = (TWO_PI * (frameCount % 200)) / 200;\n  const x = 0.5 * cos(angle);\n  const y = 0.5 * sin(angle);\n  background(0);\n  shader(myShader);\n  myShader.setUniform(\&quot;uCircle\&quot;, [x, y, 0.5]);\n  rect(0, 0, 0, 0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Listo!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Con eso es suficiente para empezar a experimentar, lo que sigue no viene con explicación. Sin embargo, puedes obtener el código inspeccionando la página.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Experimentos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Campos vectoriales 💀&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;type\&quot;:\&quot;image\&quot;,\&quot;url\&quot;:\&quot;https://mathworld.wolfram.com/images/eps-svg/VectorPlot_1000.png\&quot;}&quot;],&quot;type&quot;:[0,&quot;LinkBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;*Nota: No se aprecia muy bien las rotaciones, para notarlas mejor se podría calcular desde JS y enviar las direcciones a los shaders. Para el color se escaló la distancia en ángulo entre el origen y el destino.*&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### [-y, x]&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\n#define PI 3.1415926535897932384626433832795\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uTime;\\nfloat scale = 4.0;\\n\\nvec2 getTarget(vec2 origin) {\\n  float x = origin.x;\\n  float y = origin.y;\\n  return vec2(-y, x);\\n}\\n\\nfloat getAngleDiff(float angle1, float angle2) {\\n  float angle = angle1 - angle2;\\n  if (angle &gt; PI) {\\n    angle -= 2.0 * PI;\\n  } else if (angle &lt;= -PI) {\\n    angle += 2.0 * PI;\\n  }\\n  return angle;\\n}\\n\\nvoid main() {\\n\\n  vec2 origin = vec2(vXY.x * scale, vXY.y * scale);\\n  float angleO = atan(origin.y, origin.x);\\n\\n  vec2 target = getTarget(origin);\\n  target = (1.0 - uTime) * origin + uTime * target;\\n  float angleT = atan(target.y, target.x);\\n\\n  float eDist = length(origin - target);\\n  float aDist = getAngleDiff(angleO, angleT);\\n\\n  float eClose = 1.0 - log(eDist + 1e-9); // magia\\n  float aClose = aDist / PI + 1.0; // [0, 1]\\n\\n  float r = (eClose + aClose) / 2.0;\\n  float g = eClose;\\n  float b = (eClose + (1.0 - aClose)) / 2.0;\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  const t = (sin(frameCount / 50 + HALF_PI) - 1) / 2; // [0, 1]\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, t);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### [y, x]&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\n#define PI 3.1415926535897932384626433832795\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uTime;\\nfloat scale = 4.0;\\n\\nvec2 getTarget(vec2 origin) {\\n  float x = origin.x;\\n  float y = origin.y;\\n  return vec2(y, x);\\n}\\n\\nfloat getAngleDiff(float angle1, float angle2) {\\n  float angle = angle1 - angle2;\\n  if (angle &gt; PI) {\\n    angle -= 2.0 * PI;\\n  } else if (angle &lt;= -PI) {\\n    angle += 2.0 * PI;\\n  }\\n  return angle;\\n}\\n\\nvoid main() {\\n\\n  vec2 origin = vec2(vXY.x * scale, vXY.y * scale);\\n  float angleO = atan(origin.y, origin.x);\\n\\n  vec2 target = getTarget(origin);\\n  target = (1.0 - uTime) * origin + uTime * target;\\n  float angleT = atan(target.y, target.x);\\n\\n  float eDist = length(origin - target);\\n  float aDist = getAngleDiff(angleO, angleT);\\n\\n  float eClose = 1.0 - log(eDist + 1e-9); // magia\\n  float aClose = aDist / PI + 1.0; // [0, 1]\\n\\n  float r = (eClose + aClose) / 2.0;\\n  float g = eClose;\\n  float b = (eClose + (1.0 - aClose)) / 2.0;\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  const t = (sin(frameCount / 50 + HALF_PI) - 1) / 2; // [0, 1]\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, t);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### [x^2 - y^2 - 4, 2xy]&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;url\&quot;:\&quot;https://www.geogebra.org/resource/QPE4PaDZ/dfYUWD6GynXktJGE/material-QPE4PaDZ.png\&quot;}&quot;],&quot;type&quot;:[0,&quot;LinkBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\n#define PI 3.1415926535897932384626433832795\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uTime;\\nfloat scale = 4.0;\\n\\nvec2 getTarget(vec2 origin) {\\n  float x = origin.x;\\n  float y = origin.y;\\n  return vec2(x*x-y*y-4.0, 2.0*x*y);\\n}\\n\\nfloat getAngleDiff(float angle1, float angle2) {\\n  float angle = angle1 - angle2;\\n  if (angle &gt; PI) {\\n    angle -= 2.0 * PI;\\n  } else if (angle &lt;= -PI) {\\n    angle += 2.0 * PI;\\n  }\\n  return angle;\\n}\\n\\nvoid main() {\\n\\n  vec2 origin = vec2(vXY.x * scale, vXY.y * scale);\\n  float angleO = atan(origin.y, origin.x);\\n\\n  vec2 target = getTarget(origin);\\n  target = (1.0 - uTime) * origin + uTime * target;\\n  float angleT = atan(target.y, target.x);\\n\\n  float eDist = length(origin - target);\\n  float aDist = getAngleDiff(angleO, angleT);\\n\\n  float eClose = 1.0 - log(eDist + 1e-9); // magia\\n  float aClose = aDist / PI + 1.0; // [0, 1]\\n\\n  float r = (eClose + aClose) / 2.0;\\n  float g = eClose;\\n  float b = (eClose + (1.0 - aClose)) / 2.0;\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  const t = (sin(frameCount / 50 + HALF_PI) - 1) / 2; // [0, 1]\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, t);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;### [x^2 - y^2 - 4, 2xy] *Update (2024/06/15)*&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se implementó una mejor forma de representar el campo vectorial ✨&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\n#define PI 3.1415926535897932384626433832795\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uTime;\\nfloat scale = 4.0;\\n\\nvec2 getTarget(vec2 origin) {\\n  float x = origin.x;\\n  float y = origin.y;\\n  return vec2(x*x - y*y - 4.0, 2.0*x*y);\\n}\\n\\nfloat getAngleDiff(float angle1, float angle2) {\\n  float angle = angle1 - angle2;\\n  if (angle &gt; PI) {\\n    angle -= 2.0 * PI;\\n  } else if (angle &lt;= -PI) {\\n    angle += 2.0 * PI;\\n  }\\n  return angle;\\n}\\n\\n// https://gist.github.com/983/e170a24ae8eba2cd174f\\nvec3 hsv2rgb(vec3 c) {\\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvoid main() {\\n  vec2 origin = vec2(vXY.x * scale, vXY.y * scale);\\n  vec2 target = getTarget(origin);\\n  target = (1.0 - uTime) * origin + uTime * target;\\n\\n  float angleO = atan(origin.y, origin.x);\\n  float angleT = atan(target.y, target.x);\\n\\n  float eDist = length(origin - target);\\n  float aDist = getAngleDiff(angleO, angleT);\\n  aDist = aDist / (2.0 * PI); // [0, 1]\\n\\n  vec3 rgb = hsv2rgb(vec3(aDist, 1.0, eDist));\\n  gl_FragColor = vec4(rgb, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  const t = (sin(frameCount / 50 + HALF_PI) - 1) / 2; // [0, 1]\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, t);\\n  rect(0, 0, 0, 0);\\n}\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En términos de hsv:\n- `hue`: Representa el ángulo que se forma entré el origen y el destino.\n- `saturation`: Constante.\n- `value`: El brillo depende de la distancia euclidiana entre el origen y el destino.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Nubes&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para este experimento es necesaria una función que genere ruido. La más conocida es Perlin Noise y se usó la siguiente implementación:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;url\&quot;:\&quot;https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#classic-perlin-noise\&quot;}&quot;],&quot;type&quot;:[0,&quot;LinkBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const perlinNoise = `\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec3 P){\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 / 7.0;\\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 / 7.0;\\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n`;\\n\\nconst vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uTime;\\n\\n${perlinNoise}\\n\\nvoid main() {\\n  vec2 vSlow = vec2(vXY.x * 1.5, vXY.y * 3.0);\\n  vec2 vFast = vec2(vXY.x * 5.0, vXY.y * 5.0);\\n\\n  float slow = cnoise(vec3(vSlow, vSlow.x + uTime/10.0));\\n  float fast = cnoise(vec3(vFast, vFast.x + uTime));\\n  float cloud = fast * 0.2 + slow * 0.8;\\n\\n  vec3 skyblue = vec3(0.5, 0.8, 0.85);\\n  vec3 white = vec3(1.0);\\n\\n  vec3 color = cloud * white + (1.0 - cloud) * skyblue;\\n\\n  gl_FragColor = vec4(color, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n}\\n\\nfunction draw() {\\n  background(0);\\n  const t = frameCount / 50;\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, t);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Aquí es necesario hacer muchos cálculos al ojo, la técnica es si el ruido que va de [0, 1] está más cerca a 1 se pinta de blanco, caso contrario celeste.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Además, se añadieron nubes lentas y más grandes para dar la sensación de densidad en ciertas zonas.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Mandelbrot&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float zoom;\\nfloat scale = 2.0;\\nconst int maxIt = 300;\\n\\nvoid main() {\\n  vec2 Z = vec2(0);\\n  vec2 C = vec2(vXY * scale * zoom);\\n  C.x -= 1.7864385;\\n  int it = 0;\\n  for(int i = 0; i &lt; maxIt; ++i) {\\n    if(length(Z) &gt; 16.0) {\\n      break;\\n    }\\n    Z = vec2(\\n      Z.x*Z.x - Z.y*Z.y + C.x,\\n      2.0 * Z.x * Z.y + C.y\\n    );\\n    it++;\\n  }\\n  if(maxIt == it) it = 0;\\n  float c = float(it)/float(maxIt);\\n  c = sqrt(c);\\n  float g = c;\\n  float b = sqrt(c);\\n  float r = c * (1.0 - c);\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  mat = [];\\n  createCanvas(350, 320, WEBGL);\\n}\\n\\nlet zoom = 1;\\nlet dir = 0.99;\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;zoom\\\&quot;, zoom);\\n  rect(0, 0, 0, 0);\\n  zoom *= dir;\\n  if (zoom &lt; 2e-6) dir = 1 + (1 - dir);\\n  if (zoom &gt; 2) dir = 2 - dir;\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota: Si esperas a que termine el zoom, notarás el límite de la precisión para los decimales.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Mandelbulb&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Adaptación de: https://editor.p5js.org/Taxen99/sketches/47CDg5-nV&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Este fue el motivo por el cuál quería aprender shaders, calcular el conjunto de Mandelbulb en JS es muy lento. Incluso en Java esto toma su tiempo y el renderizado no es muy intuitivo.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Como pendiente, haré un post aparte intentando explicar cómo desarrollarlo. Cuando lo tenga listo pondré el enlace en esta sección. 🐵&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;*Update (2024/06/15)*\n\nLo prometido es deuda: [Mandelbulb en GLSL](/blog/mandelbulb-en-glsl)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;// Reference: https://editor.p5js.org/Taxen99/sketches/47CDg5-nV\\n\\nconst vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 vXY;\\nuniform float uTime;\\n\\nvec3 toSpherical(vec3 v) {\\n  float r = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\\n  float theta = atan(sqrt(v.x * v.x + v.y * v.y), v.z);\\n  float phi = atan(v.y, v.x);\\n  return vec3(r, theta, phi);\\n}\\n\\nfloat calcEstDist(vec3 pos, float power, const int maxIt) {\\n  vec3 zeta = pos;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  for (int n = 0; n &gt; -1; n++) {\\n    if(n &gt; maxIt) break;\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n    float powx =\\n      pow(spherical.x, power) *\\n      sin(spherical.y * power) *\\n      cos(spherical.z * power);\\n    float powy =\\n      pow(spherical.x, power) *\\n      sin(spherical.y * power) *\\n      sin(spherical.z * power);\\n    float powz =\\n      pow(spherical.x, power) *\\n      cos(spherical.y * power);\\n    zeta.x = powx + pos.x;\\n    zeta.y = powy + pos.y;\\n    zeta.z = powz + pos.z;\\n  }\\n  return 0.5 * log(r) * r / dr;\\n}\\n\\nmat3 rotY(float angle) {\\n  float s = sin(angle);\\n  float c = cos(angle);\\n  return mat3(\\n      c, 0.0,  -s,\\n    0.0, 1.0, 0.0,\\n      s, 0.0,   c\\n  );\\n}\\n\\nvoid main() {\\n  float power = 1.0 + uTime / 2.0;\\n  power = min(power, 10.0);\\n  float angle = uTime / 2.0;\\n  mat3 rot = rotY(angle);\\n\\n  vec3 pos = vec3(vXY.xy / 2.5 + 0.5, 1.0);\\n  pos.xy = pos.xy * 3.0 - 1.5;\\n\\n  pos = rot * pos;\\n  vec3 forward = rot * vec3(0, 0, 1.0);\\n\\n  float distEst = 1.0;\\n  const int maxIt = 100;\\n  int it = 0;\\n  float totalDist = 0.0;\\n\\n  for(int i = 0; i &lt; maxIt; i++) {\\n    if(!(distEst &gt; 0.001 &amp;&amp; totalDist &lt; 2.0)) break;\\n    distEst = calcEstDist(pos, power, 10);\\n    totalDist += distEst;\\n    pos -= forward * distEst;\\n    it += 1;\\n  }\\n\\n  if(it &gt; maxIt) it = maxIt;\\n  if(totalDist &gt;= 2.0) it = maxIt;\\n  float color = abs(float(it) / float(maxIt) - 1.0);\\n  if(color &gt; 0.001) {\\n    float r = log(color + 1.0);\\n    float g = color * color;\\n    float b = sqrt(1.0 - color);\\n    gl_FragColor = vec4(r, g, b, 1.0);\\n  }\\n  else {\\n    gl_FragColor = vec4(0, 0, 0, 1.0);\\n  }\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  mat = [];\\n  createCanvas(350, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  let uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota mental: es increíble que todo esto pueda correr en el navegador 🤯&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## El juego de la vida de Conway&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Aquí la idea es guardar el estado en JS (ya que glsl no puede guardar estados entre frames) y calcular el siguiente estado con los shaders.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Glsl permite uniforms de imágenes llamados [`sampler2D`](https://thebookofshaders.com/glossary/?search=texture2D), representan texturas y en este experimento se carga el estado inicial que es el canvas previo. El inicial son varios puntos aleatorios.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist &lt; 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i &lt; uStateSize; i++) {\\n    for (let j = 0; j &lt; uStateSize; j++) {\\n      if (random(1) &gt; 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Mi intención era implementar [Lenia](https://es.wikipedia.org/wiki/Lenia), pero tiene DEMASIADAS reglas. Pueden verlo en este video: https://www.youtube.com/watch?v=6kiBYjvyojQ&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota: Usar [`get`](https://p5js.org/reference/#/p5/get) en P5js para enviar el estado actual, da error en mobile después de algunos frames. Esto no sucede al usar `createGraphics`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Referencias\n- https://thebookofshaders.com/\n- https://itp-xstory.github.io/p5js-shaders/\n- https://editor.p5js.org/Taxen99/sketches/47CDg5-nV&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}]]],&quot;isPinned&quot;:[0,true],&quot;slugUrl&quot;:[0,&quot;shaders-en-corto&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Mayo 7, 2024</div><p class="text-neutral-400 text-xs flex gap-1">8 minutos de lectura </p></div><h1>Shaders en corto</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">Índice:</h2><div><!----><ul><!--[--><li><a href="/blog/shaders-en-corto/#shaders" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Shaders"><p>Shaders</p>
</a><ul><!--[--><li><a href="/blog/shaders-en-corto/#glsl-p5js" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="GLSL + P5js"><p>GLSL + P5js</p>
</a><ul><!--[--><li><a href="/blog/shaders-en-corto/#vertex-shaders" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Vertex shaders"><p>Vertex shaders</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#fragment-shaders" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Fragment shaders"><p>Fragment shaders</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/shaders-en-corto/#sketch-p5js" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Sketch P5js"><p>Sketch P5js</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/shaders-en-corto/#esencial" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Esencial"><p>Esencial</p>
</a><ul><!--[--><li><a href="/blog/shaders-en-corto/#crculos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Círculos"><p>Círculos</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#cuadrados" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Cuadrados"><p>Cuadrados</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#movimiento" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Movimiento"><p>Movimiento</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/shaders-en-corto/#listo" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Listo!"><p>Listo!</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#experimentos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Experimentos"><p>Experimentos</p>
</a><ul><!--[--><li><a href="/blog/shaders-en-corto/#campos-vectoriales" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Campos vectoriales 💀"><p>Campos vectoriales 💀</p>
</a><ul><!--[--><li><a href="/blog/shaders-en-corto/#y-x" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="[-y, x]"><p>[-y, x]</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#y-x" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="[y, x]"><p>[y, x]</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#x2-y2-4-2xy" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="[x^2 - y^2 - 4, 2xy]"><p>[x^2 - y^2 - 4, 2xy]</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#x2-y2-4-2xy-update-20240615" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="[x^2 - y^2 - 4, 2xy] *Update (2024/06/15)*"><p>[x^2 - y^2 - 4, 2xy] <em>Update (2024/06/15)</em></p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/shaders-en-corto/#nubes" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Nubes"><p>Nubes</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#mandelbrot" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Mandelbrot"><p>Mandelbrot</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#mandelbulb" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Mandelbulb"><p>Mandelbulb</p>
</a><!----></li><li><a href="/blog/shaders-en-corto/#el-juego-de-la-vida-de-conway" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="El juego de la vida de Conway"><p>El juego de la vida de Conway</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/shaders-en-corto/#referencias" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Referencias"><p>Referencias</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Hola! esta vez intentaré plasmar lo que aprendí sobre shaders. Se implementarán algunos temas en el contexto de shaders. Con un poco de fe, espero sirva.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Los shaders se aplican sobre objetos 3D, por lo que es necesario contar con uno antes de usarlos (spoiler: solo se usa un cuadrado).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h1 class="font-mono" id="shaders">Shaders</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Los shaders son una forma especial de renderizar gráficos. A diferencia de mostrar un círculo en una pantalla (con algún lenguaje de programación), el equivalente en shaders sería saber si una coordenada pertenece a ese círculo y determinar que color asignarle.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Hay muchas suposiciones incompletas en esa definición, pero, es suficiente para saber que no son una forma tradicional de programar con gráficos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="glsl-p5js">GLSL + P5js</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>GLSL es el lenguaje de programación para shaders. El cómo se comunica un shader con un programa depende mucho de la plataforma. P5js es una librería que facilita trabajar con shaders en el navegador usando WEBGL.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><ul>
<li>Vertex shader: Define dónde renderizar el vértice evaluado</li>
<li>Fragment shader: Define el color a renderizar cuando se evalúa una coordenada respecto al objeto.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="vertex-shaders">Vertex shaders</h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>P5js ofrece la propiedad <code>aPosition</code> como coordenadas del vértice.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>En P5js los vértices están en el rango de [0, 1] y para renderizarlo como se &quot;espera&quot;, es necesario escalarlo a un rango entre [-1, 1].</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para definir la posición del vértice, se tiene que asignar un vector a <code>gl_Position</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-glsl"><span class="hljs-comment">// shader.vert</span>
<span class="hljs-keyword">attribute</span> <span class="hljs-type">vec3</span> aPosition;

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec4</span> pos = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);
  pos = pos * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;
  <span class="hljs-built_in">gl_Position</span> = pos;
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="fragment-shaders">Fragment shaders</h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para definir el color a renderizar, se tiene que asignar un vector (que representa un color) a <code>gl_FragColor</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-glsl"><span class="hljs-comment">// shader.frag</span>
<span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;

<span class="hljs-type">void</span> main() {
  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p><em>Nota: GLSL es estricto con el uso de coma flotante (<code>float</code>), además, es necesario definir la precisión.</em></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="sketch-p5js">Sketch P5js</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para cargar un shader en P5js, es necesario especificar que se usará WEBGL al crear el canvas.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">let</span> myShader;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">preload</span>(<span class="hljs-params"></span>) {
  myShader = <span class="hljs-title function_">loadShader</span>(<span class="hljs-string">&quot;shader.vert&quot;</span>, <span class="hljs-string">&quot;shader.frag&quot;</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">shader</span>(myShader);
  <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p><em>Nota: El <code>rect</code> se define con un tamaño 0. Esto es algo específico de P5js (con algunas figuras en 2D), cuando se carga un shader este ignora los parámetros definidos. Sin embargo, si se respetan las proporciones de los vértices.</em></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para probarlo es posible cargar los shaders en <code>createShader</code> como strings.</p>
<p>Copia y pega lo siguiente en:
<a href="https://editor.p5js.org/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/</a></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> vertShader = <span class="hljs-string">`
attribute vec3 aPosition;

void main() {
  vec4 pos = vec4(aPosition, 1.0);
  pos = pos * 2.0 - 1.0;
  gl_Position = pos;
}

`</span>;

<span class="hljs-keyword">const</span> fragShader = <span class="hljs-string">`
precision mediump float;

void main() {
  gl_FragColor = vec4(1.0, 0, 0, 1.0);
}
`</span>;

<span class="hljs-keyword">let</span> myShader;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  myShader = <span class="hljs-title function_">createShader</span>(vertShader, fragShader);
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">shader</span>(myShader);
  <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Se usará este sketch como referencia en los siguientes ejemplos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h1 class="font-mono" id="esencial">Esencial</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="crculos">Círculos</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para determinar un color en función de la posición, es necesario comunicar al <code>fragment shader</code> la posición. Esto es posible definiendo variables las cuales pueden compartir ambos <code>vertex shader</code> y <code>fragment shader</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-glsl"><span class="hljs-comment">// shader.vert</span>
<span class="hljs-keyword">attribute</span> <span class="hljs-type">vec3</span> aPosition;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> vXY; <span class="hljs-comment">// VARIABLE COMPARTIDA</span>

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec4</span> pos = <span class="hljs-type">vec4</span>(aPosition, <span class="hljs-number">1.0</span>);
  pos = pos * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;
  vXY = pos.xy;
  <span class="hljs-built_in">gl_Position</span> = pos;
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Luego se puede recibir desde el <code>fragment shader</code> la variable <code>vXY</code>:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-glsl"><span class="hljs-comment">// shader.frag</span>
<span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> vXY; <span class="hljs-comment">// VARIABLE COMPARTIDA</span>

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">float</span> radius = <span class="hljs-number">0.5</span>;
  <span class="hljs-type">vec2</span> circle1 = <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>);
  <span class="hljs-type">vec2</span> circle2 = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);

  <span class="hljs-type">float</span> color = <span class="hljs-built_in">min</span>(
    <span class="hljs-built_in">step</span>(radius, <span class="hljs-built_in">length</span>(vXY - circle1.xy)),
    <span class="hljs-built_in">step</span>(radius, <span class="hljs-built_in">length</span>(vXY - circle2.xy))
  );

  color = <span class="hljs-number">1.0</span> - color;
  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(color), <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Explicación: Para determinar el color, primero se calcula la distancia a alguno de los círculos. Con la función <code>length</code> se puede obtener la distancia euclidiana al origen, en este caso se suma para hacer una traslación respecto al punto evaluado. Luego <code>step</code> devuelve <code>1</code> si la distancia es mayor a <code>radius</code>, por ese motivo se invierte el color antes de definirlo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="cuadrados">Cuadrados</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-glsl"><span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> vXY;

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">float</span> size1 = <span class="hljs-number">0.5</span>;
  <span class="hljs-type">vec2</span> square1 = <span class="hljs-type">vec2</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);
  <span class="hljs-type">float</span> size2 = <span class="hljs-number">0.25</span>;
  <span class="hljs-type">vec2</span> square2 = <span class="hljs-type">vec2</span>(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>);
  <span class="hljs-type">float</span> x = vXY.x;
  <span class="hljs-type">float</span> y = vXY.y;
  <span class="hljs-type">float</span> color = <span class="hljs-built_in">min</span>((
      <span class="hljs-built_in">step</span>(size1, <span class="hljs-built_in">abs</span>(square1.x - x)) +
      <span class="hljs-built_in">step</span>(size1, <span class="hljs-built_in">abs</span>(square1.y - y))
    ), (
      <span class="hljs-built_in">step</span>(size2, <span class="hljs-built_in">abs</span>(square2.x - x)) +
      <span class="hljs-built_in">step</span>(size2, <span class="hljs-built_in">abs</span>(square2.y - y))
  ));
  color = <span class="hljs-number">1.0</span> - color;
  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(color), <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Explicación: A diferencia del círculo, los cuadrados se pueden determinar con una distancia <code>manhattan</code> que sería simplemente sumar si se encuentra en el rango del eje <code>x</code> con si se encuentra en el eje <code>y</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="movimiento">Movimiento</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para compartir variables desde JS a los shaders, se utilizan los <code>uniform</code>. En este ejemplo se comparte la posición y el radio como un <code>vec3</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> vertShader = <span class="hljs-string">`
attribute vec3 aPosition;
varying vec2 vXY;

void main() {
  vec4 pos = vec4(aPosition, 1.0);
  pos = pos * 2.0 - 1.0;
  vXY = pos.xy;
  gl_Position = pos;
}

`</span>;

<span class="hljs-keyword">const</span> fragShader = <span class="hljs-string">`
precision mediump float;
varying vec2 vXY;
uniform vec3 uCircle;

void main() {
  float radius = uCircle.z;
  float color = step(radius, length(vXY - uCircle.xy));
  color = 1.0 - color;
  gl_FragColor = vec4(vec3(color), 1.0);
}
`</span>;

<span class="hljs-keyword">let</span> myShader;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  myShader = <span class="hljs-title function_">createShader</span>(vertShader, fragShader);
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> angle = (<span class="hljs-variable constant_">TWO_PI</span> * (frameCount % <span class="hljs-number">200</span>)) / <span class="hljs-number">200</span>;
  <span class="hljs-keyword">const</span> x = <span class="hljs-number">0.5</span> * <span class="hljs-title function_">cos</span>(angle);
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">0.5</span> * <span class="hljs-title function_">sin</span>(angle);
  <span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title function_">shader</span>(myShader);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uCircle&quot;</span>, [x, y, <span class="hljs-number">0.5</span>]);
  <span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h1 class="font-mono" id="listo">Listo!</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Con eso es suficiente para empezar a experimentar, lo que sigue no viene con explicación. Sin embargo, puedes obtener el código inspeccionando la página.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h1 class="font-mono" id="experimentos">Experimentos</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="campos-vectoriales">Campos vectoriales 💀</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black bg-opacity-30 font-sans" slugurl="shaders-en-corto"><!----><img loading="lazy" class="h-80 w-fit mx-auto object-contain bg-white" src="https://mathworld.wolfram.com/images/eps-svg/VectorPlot_1000.png"><p class="bg-black text-end text-xs text-ellipsis overflow-hidden whitespace-nowrap"><a class="ml-16" href="https://mathworld.wolfram.com/images/eps-svg/VectorPlot_1000.png" target="_blank">https://mathworld.wolfram.com/images/eps-svg/VectorPlot_1000.png</a></p></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p><em>Nota: No se aprecia muy bien las rotaciones, para notarlas mejor se podría calcular desde JS y enviar las direcciones a los shaders. Para el color se escaló la distancia en ángulo entre el origen y el destino.</em></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="y-x">[-y, x]</h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="y-x">[y, x]</h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="x2-y2-4-2xy">[x^2 - y^2 - 4, 2xy]</h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black bg-opacity-30 font-sans" slugurl="shaders-en-corto"><!----><!----><p class="bg-black text-end text-xs text-ellipsis overflow-hidden whitespace-nowrap"><a class="ml-16" href="https://www.geogebra.org/resource/QPE4PaDZ/dfYUWD6GynXktJGE/material-QPE4PaDZ.png" target="_blank">https://www.geogebra.org/resource/QPE4PaDZ/dfYUWD6GynXktJGE/material-QPE4PaDZ.png</a></p></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h3 class="font-mono" id="x2-y2-4-2xy-update-20240615">[x^2 - y^2 - 4, 2xy] <em>Update (2024/06/15)</em></h3></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Se implementó una mejor forma de representar el campo vectorial ✨</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>En términos de hsv:</p>
<ul>
<li><code>hue</code>: Representa el ángulo que se forma entré el origen y el destino.</li>
<li><code>saturation</code>: Constante.</li>
<li><code>value</code>: El brillo depende de la distancia euclidiana entre el origen y el destino.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="nubes">Nubes</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Para este experimento es necesaria una función que genere ruido. La más conocida es Perlin Noise y se usó la siguiente implementación:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black bg-opacity-30 font-sans" slugurl="shaders-en-corto"><!----><!----><p class="bg-black text-end text-xs text-ellipsis overflow-hidden whitespace-nowrap"><a class="ml-16" href="https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#classic-perlin-noise" target="_blank">https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#classic-perlin-noise</a></p></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Aquí es necesario hacer muchos cálculos al ojo, la técnica es si el ruido que va de [0, 1] está más cerca a 1 se pinta de blanco, caso contrario celeste.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Además, se añadieron nubes lentas y más grandes para dar la sensación de densidad en ciertas zonas.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="mandelbrot">Mandelbrot</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Nota: Si esperas a que termine el zoom, notarás el límite de la precisión para los decimales.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="mandelbulb">Mandelbulb</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Adaptación de: <a href="https://editor.p5js.org/Taxen99/sketches/47CDg5-nV" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/Taxen99/sketches/47CDg5-nV</a></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Este fue el motivo por el cuál quería aprender shaders, calcular el conjunto de Mandelbulb en JS es muy lento. Incluso en Java esto toma su tiempo y el renderizado no es muy intuitivo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Como pendiente, haré un post aparte intentando explicar cómo desarrollarlo. Cuando lo tenga listo pondré el enlace en esta sección. 🐵</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p><em>Update (2024/06/15)</em></p>
<p>Lo prometido es deuda: <a href="/blog/mandelbulb-en-glsl" title="null" class="text-primary [word-break:break-word]" target="_blank">Mandelbulb en GLSL</a></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Nota mental: es increíble que todo esto pueda correr en el navegador 🤯</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h2 class="font-mono" id="el-juego-de-la-vida-de-conway">El juego de la vida de Conway</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Aquí la idea es guardar el estado en JS (ya que glsl no puede guardar estados entre frames) y calcular el siguiente estado con los shaders.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Glsl permite uniforms de imágenes llamados <a href="https://thebookofshaders.com/glossary/?search=texture2D" title="null" class="text-primary [word-break:break-word]" target="_blank"><code>sampler2D</code></a>, representan texturas y en este experimento se carga el estado inicial que es el canvas previo. El inicial son varios puntos aleatorios.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="shaders-en-corto"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Mi intención era implementar <a href="https://es.wikipedia.org/wiki/Lenia" title="null" class="text-primary [word-break:break-word]" target="_blank">Lenia</a>, pero tiene DEMASIADAS reglas. Pueden verlo en este video: <a href="https://www.youtube.com/watch?v=6kiBYjvyojQ" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://www.youtube.com/watch?v=6kiBYjvyojQ</a></p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><p>Nota: Usar <a href="https://p5js.org/reference/#/p5/get" title="null" class="text-primary [word-break:break-word]" target="_blank"><code>get</code></a> en P5js para enviar el estado actual, da error en mobile después de algunos frames. Esto no sucede al usar <code>createGraphics</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="shaders-en-corto"><div class="font-sans w-full"><h1 class="font-mono" id="referencias">Referencias</h1><ul>
<li><a href="https://thebookofshaders.com/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://thebookofshaders.com/</a></li>
<li><a href="https://itp-xstory.github.io/p5js-shaders/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://itp-xstory.github.io/p5js-shaders/</a></li>
<li><a href="https://editor.p5js.org/Taxen99/sketches/47CDg5-nV" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/Taxen99/sketches/47CDg5-nV</a></li>
</ul>
</div></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html> 