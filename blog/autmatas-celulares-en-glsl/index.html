<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Autómatas celulares en GLSL"><meta name="twitter:title" content="Autómatas celulares en GLSL"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #edu #art"><meta property="og:description" content="Tags: #tech #edu #art"><meta name="twitter:description" content="Tags: #tech #edu #art"><meta property="og:image" content="https://moloxe.github.io/blog/autmatas-celulares-en-glsl/img/automata.gif"><meta name="twitter:image" content="https://moloxe.github.io/blog/autmatas-celulares-en-glsl/img/automata.gif"><meta name="generator" content="Astro v5.13.7"><title>Autómatas celulares en GLSL</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.U4jOVs4w.js"></script><link rel="stylesheet" href="/_astro/index.C9DwYtz5.css">
<style>:root{font-weight:200;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.edit-block{overflow:hidden;border-radius:.25rem;--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
.astro-route-announcer{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media (prefers-reduced-motion){::view-transition-group(*),::view-transition-old(*),::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}
</style>
<link rel="stylesheet" href="/_astro/index.BG8E1MYw.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.Jt7Qpvtv.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-xs font-mono p-2 text-neutral-400 leading-5 break-all"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/autmatas-celulares-en-glsl" class="hover:text-white">autmatas-celulares-en-glsl</a>  </p>  <div class="flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="ZMg413" prefix="s0" component-url="/_astro/PostView.BmyaVLYq.js" component-export="default" renderer-url="/_astro/client.CR2cEPN5.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Autómatas celulares en GLSL&quot;],&quot;creationDate&quot;:[3,&quot;2024-06-23T23:08:25.980Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2024-09-02T05:07:28.136Z&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;edu&quot;],[0,&quot;art&quot;]]],&quot;container&quot;:[1,[[0,{&quot;text&quot;:[0,&quot;Tercera y última continuación espiritual de [shaders en corto](/blog/shaders-en-corto). Con este post me voy de vacaciones de los shaders. Probablemente los siga usando, pero no escribiré más posts enfocados en GLSL.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Un adelanto del resultado final:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;/automata.gif&quot;],&quot;type&quot;:[0,&quot;ImageBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Viendo la complejidad que tiene [Lenia](https://es.wikipedia.org/wiki/Lenia) para ser implementado, en este post se experimentará específicamente haciendo una versión del juego de la vida más \&quot;suave\&quot; (ya existen btw).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist &lt; 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i &lt; uStateSize; i++) {\\n    for (let j = 0; j &lt; uStateSize; j++) {\\n      if (random(1) &gt; 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Las reglas del juego de la vida se pueden encontrar en Wikipedia 🗿:\n- Nace: Si una célula muerta tiene exactamente 3 células vecinas vivas \&quot;nace\&quot; (es decir, al turno siguiente estará viva).\n- Muere: una célula viva puede morir por uno de 2 casos:\n  - Sobrepoblación: si tiene más de tres vecinos alrededor.\n  - Aislamiento: si tiene solo un vecino alrededor o ninguno.\n- Vive: una célula se mantiene viva si tiene 2 o 3 vecinos a su alrededor.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida proporcional&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El juego de la vida es algo determinante y el primer experimento es cambiar las reglas a algo más flexible. Las reglas quedarían así:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, 3]`: Vida aumenta en `n/3`.\n- `3 a más`: Vida disminuye en `n/8` (el máximo de `n` es 8).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para ver la diferencia, se usará el siguiente estado inicial:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  const points = 50;\\n  for (let i = 0; i &lt; points; i++) {\\n    const x = 50 * cos((TWO_PI * i) / points);\\n    const y = 50 * sin((TWO_PI * i) / points);\\n    g.point(x, y);\\n  }\\n\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n  frameRate(14);\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Y con las nuevas reglas:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uGap;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  float live = getState(i, j);\\n  float tl = getState(i - 1, j - 1);\\n  float t = getState(i, j - 1);\\n  float tr = getState(i + 1, j - 1);\\n  float l = getState(i - 1, j);\\n  float r = getState(i + 1, j);\\n  float bl = getState(i - 1, j + 1);\\n  float b = getState(i, j + 1);\\n  float br = getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(n &lt;= 1.0) {\\n    live -= n;\\n  } else if(n &lt;= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / 8.0;\\n  }\\n\\n  gl_FragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\n\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt; points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() =&gt; {\\n    restart();\\n  });\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Viene con trucos:\n- Se cambió el rango de aumentar vida de `[1, 3]` a `[1, 1.5]`. Simplemente porque se ve mejor 👍. Se puede probar otros valores moviendo el slider, representa el `gap` para aumentar la vida. El máximo es 8, lo cual hace que crezca sin parar.\n- Esquinas redondeadas: Suponiendo que la distancia horizontal y vertical es de 1, la vida de las celdas diagonales se multiplicó por `1 / sqrt(2)` (solo se considera la vida proporcionalmente a la distancia horizontal y vertical).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Valores cercanos a 4 (como el del ejemplo) forman patrones rectos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida proporcional y zonal&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En este experimento se aumentará el área considerada para los vecinos. Con ello se tendrían 2 variables `gap` (que representa la formación de vida) y `r` (el radio considerado para los vecinos).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Las reglas ahora son, siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, gap]`: Vida aumenta en `n/gap`.\n- `gap a más`: Vida disminuye en `n/totalN`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No hay una explicación \&quot;lógica\&quot; para `totalN`, solo se sigue la corriente de lo que se propuso antes con `1 / sqrt(2)` para las esquinas.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`totalN`: Representa la suma de las distancias proporcionales de los vecinos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Por ejemplo:\n```glsl\nfloat dist = length(vec2(i, j) - vec2(k, l)); // Distance de la celda evaluada (i, j) al vecino (k, l)\nfloat factor = 1.0 / dist; // Variable propuesta\nfloat curLive = getState(k, l) * factor;\nn += curLive;\ntotalN += factor;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  float totalN = 0.0;\\n  for(float k = i - uR; k &lt;= i + uR; k++) {\\n    for(float l = j - uR; l &lt;= j + uR; l++) {\\n      if(i == k &amp;&amp; j == l) continue;\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float curLive = getState(k, l) * factor;\\n      n += curLive;\\n      totalN += factor;\\n    }\\n  }\\n\\n  if(n &lt;= 1.0) {\\n    live -= n;\\n  } else if(n &lt;= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / totalN;\\n  }\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 3.0, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 4, 1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt; points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() =&gt; {\\n    restart();\\n  });\\n  rSlider.input(() =&gt; {\\n    restart();\\n  });\\n  restart();\\n\\n  frameRate(4);\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Dos puntos a tener en cuenta:\n- El primer slider es el `gap` de vida y el segundo el radio `r` para considerar vecinos.\n- Se hizo upgrade a la versión de GLSL para usar las variables de los loops como índices (no es importante, solo quería mencionarlo).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Tunenado el juego de la vida&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el experimente anterior se percibe un cambio drástico entre estados (por eso se redujo a 4 frames por segundo), a este punto solo se busca que se formen patrones más consistentes entre frames (ya ni se aplican las reglas propuestas previamente).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## `live += (uGap - n) * n`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // :D\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  float change = (uGap - n) * n;\\n  live += change;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 10, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- Primer slider: `gap`\n- Segundo slider: Radio para considerar un vecino (`r`). &quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Hay muchos sacrilegios tomados para hacer que luzca genial 🙂. No deberían ser problema, el código principal es el siguiente:\n\n```glsl\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  float live = getState(i, j);\n\n  float n = 0.0;\n  for(float r = 1.0; r &lt;= uR; r++) {\n    float points = 8.0 * r;\n    for(float p = 0.0; p &lt; points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 100.0 / dist; // 😉\n      float klLive = getState(k, l) * factor;\n      n += klLive;\n    }\n  }\n\n  live += (uGap - n) * n;\n\n  fragColor = vec4(vec3(live), 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El factor tomó un papel importante, reduce el impacto de los vecinos más lejanos. El cálculo del nuevo estado se redujo a `live += (uGap - n) * n;`, se omitió el caso de aislamientos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pero parece que no son suficientes cambios para ver una interacción más suave. Tiene el aspecto que hay mucha probabilidad de sobrevivir, pero el aspecto es más orgánico.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Con estos resultados se ven 2 oportunidades:\n- Dar más posibilidad de sobrevivir a casos medios.\n- Se puede reducir las reglas a una fórmula para obtener patrones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Una fórmula que me interesó mucho es la siguiente, da patrones más consistentes.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## `live += -n * log(n) + n * uGap`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // 😉\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  live += -n * log(n) + n * uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pero los cambios entre estados ahora son más fuerte fuertes (ósea se mueve más rápido). Por lo que hay que dar más chance a la muerte o reducir el impacto de los vecinos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# `live += -pow(n - uGap, 2.0) + uGap`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Después de rebuscar valores que generen patrones orgánicos, se encontró que con esta regla se pueden conseguir. Los valores son algo rebuscados pero se consiguió una función que representa bien un juego suave:\n- https://www.desmos.com/calculator/hzovhepzko&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 12.9, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se dejó el factor en `float factor = 1.0 / dist;` (tiene más sentido) y los parámetros son los siguientes:\n- `gap`: 12.9\n- `r`: 5&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Sin embargo, después de unas iteraciones el patrón se vuelve caótico. Aunque, ese inicio es un logro.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 18, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En este ejemplo se renderizan varios puntos aleatorios como estado inicial. Dale play (tanto como gustes 🙂) para ver distintos patrones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida tuneado + colores&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Último experimento. Darle un poco de vida con colores. Podrían modificarse las reglas para generar distintos estados dependiendo del color y es justo lo que se muestra a continuación:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Ahora los patrones son más estables y quedan varias células autosuficientes. Los parámetros son:\n- `gap`: 13\n- Radio `r`: 5&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se tienen 3 dimensiones por celda. Se calculan vecinos por cada dimension, por lo que `n` ahora es un `vec3`. La interacción en este caso es pasar una dimensión distinta para el cálculo de la celda evaluada:\n\n```glsl\nlive.r += -pow(n.b - uGap, 2.0) + uGap;\nlive.g += -pow(n.r - uGap, 2.0) + uGap;\nlive.b += -pow(n.g - uGap, 2.0) + uGap;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Algo a notar es que hay patrones de expansión rectos, esto es por el cálculo de la vida en la vecindad. Se usan coordenadas polares, se da una vuelta y se va ampliando el radio. El problema está en la cantidad de puntos que se evalúan por radio, como se muestra:\n\n```glsl\nfloat points = 8.0 * r;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Aumentando la cantidad de puntos por radio requiere buscar otros parámetros, pero esto mejora en la estabilidad de los patrones:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 17.5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- `gap`: 17.5\n- `r`: 4&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para estabilizar los colores se puede hacer más dependiente a cada dimensión de las demás, un buen patron encontrado es el siguiente:\n\n```glsl\nlive.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\nlive.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\nlive.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n  live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n  live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13.4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Ejecútalo varias veces, se obtienen patrones bastante suaves pero hay momentos caóticos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota final:\n\nMuchos de los cálculos desde *tunear* son buscados al ojo. Son experimentos para pasar el rato (uno bueno). Si tienes alguna propuesta, feliz de escucharla o probarla!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Recursos:\n- [Shaders en corto](/blog/shaders-en-corto)\n- https://es.wikipedia.org/wiki/Juego_de_la_vida&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No puedo terminar sin antes recrear el primer ejemplo con el nuevo autómata creado!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n\\n  vec2 pos = (vXY * 2.0 - 1.0);\\n  pos.x *= (uWidth / uHeight);\\n  float circleDist = length(pos - uCircle);\\n  \\n  if(circleDist &lt; 0.1) {\\n    live = vec3(1.0);\\n  } else {\\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n  }\\n\\n  fragColor = vec4(live, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\n\\nfunction setup() {\\n  createCanvas(350, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  restart();\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, 5);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, 13.7);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Por esta ocasión pondré todo el código aquí (siempre está disponible inspeccionando el iframe), puedes pegarlo y editarlo aquí:\n- https://editor.p5js.org/&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\np5.RendererGL.prototype._initContext = function () {\n  try {\n    this.drawingContext =\n      this.canvas.getContext(\&quot;webgl2\&quot;, this._pInst._glAttributes) ||\n      this.canvas.getContext(\&quot;experimental-webgl\&quot;, this._pInst._glAttributes);\n    if (this.drawingContext === null) {\n      throw new Error(\&quot;Error creating webgl context\&quot;);\n    } else {\n      const gl = this.drawingContext;\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      this._viewport = this.drawingContext.getParameter(\n        this.drawingContext.VIEWPORT\n      );\n    }\n  } catch (er) {\n    throw er;\n  }\n};\n\nconst vertShader = `#version 300 es\nin vec3 aPosition;\nout vec2 vXY;\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  vXY = pos.xy;\n  pos = pos * 2.0 - 1.0;\n  gl_Position = pos;\n}`;\n\nconst fragShader = `#version 300 es\nprecision mediump float;\nin vec2 vXY;\nuniform float uWidth;\nuniform float uHeight;\nuniform float uR;\nuniform float uLGap;\nuniform float uGap;\nuniform sampler2D uState;\nuniform vec2 uCircle;\nout vec4 fragColor;\nconst float PI = 3.14159264;\n\nvec3 getState(float i, float j) {\n  vec4 data = texture(\n    uState,\n    vec2(\n      (i + 0.5) / uWidth,\n      (j + 0.5) / uHeight\n    )\n  );\n  return data.rgb;\n}\n\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  vec3 live = getState(i, j);\n\n  vec3 n = vec3(0.0);\n  for(float r = 1.0; r &lt;= uR; r++) {\n    float points = 16.0 * r;\n    for(float p = 0.0; p &lt; points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 1.0 / dist;\n      vec3 klLive = getState(k, l) * factor;\n      n.r += klLive.r;\n      n.g += klLive.g;\n      n.b += klLive.b;\n    }\n  }\n\n  vec2 pos = (vXY * 2.0 - 1.0);\n  pos.x *= (uWidth / uHeight);\n  float circleDist = length(pos - uCircle);\n  \n  if(circleDist &lt; 0.1) {\n    live = vec3(1.0);\n  } else {\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n  }\n\n  fragColor = vec4(live, 1.0);\n}\n`;\n\nlet myShader;\nlet g;\n\nfunction setup() {\n  createCanvas(350, 320, WEBGL);\n  g = createGraphics(320, 320, WEBGL);\n  myShader = createShader(vertShader, fragShader);\n\n  g.shader(myShader);\n  g.stroke(255);\n  g.fill(255);\n\n  function restart() {\n    g.background(0);\n\n    const points = 3000;\n    for (let i = 0; i &lt;= points; i++) {\n      const x = width * (random(2) - 1);\n      const y = height * (random(2) - 1);\n      g.stroke(color(random(255), random(255), random(255)));\n      g.point(x, y);\n    }\n\n    imageMode(CENTER);\n    image(g, 0, 0, width, height);\n  }\n\n  restart();\n}\n\nfunction draw() {\n  const angle = frameCount / 80;\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\n  myShader.setUniform(\&quot;uState\&quot;, g);\n  myShader.setUniform(\&quot;uCircle\&quot;, uCircle);\n  myShader.setUniform(\&quot;uR\&quot;, 5);\n  myShader.setUniform(\&quot;uGap\&quot;, 13.7);\n  myShader.setUniform(\&quot;uWidth\&quot;, width);\n  myShader.setUniform(\&quot;uHeight\&quot;, height);\n  g.rect(0, 0, 0, 0);\n  imageMode(CENTER);\n  image(g, 0, 0, width, height);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}]]],&quot;isPinned&quot;:[0,false],&quot;slugUrl&quot;:[0,&quot;autmatas-celulares-en-glsl&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Junio 23, 2024</div><p class="text-neutral-400 text-xs flex gap-1">7 minutos de lectura </p></div><h1>Autómatas celulares en GLSL</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">Índice:</h2><div><!----><ul><!--[--><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-proporcional" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida proporcional"><p>Juego de la vida proporcional</p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-proporcional-y-zonal" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida proporcional y zonal"><p>Juego de la vida proporcional y zonal</p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#tunenado-el-juego-de-la-vida" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Tunenado el juego de la vida"><p>Tunenado el juego de la vida</p>
</a><ul><!--[--><li><a href="/blog/autmatas-celulares-en-glsl/#live-ugap-n-n" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += (uGap - n) * n`"><p><code>live += (uGap - n) * n</code></p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#live-n-logn-n-ugap" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += -n * log(n) + n * uGap`"><p><code>live += -n * log(n) + n * uGap</code></p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/autmatas-celulares-en-glsl/#live-pown-ugap-20-ugap" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += -pow(n - uGap, 2.0) + uGap`"><p><code>live += -pow(n - uGap, 2.0) + uGap</code></p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-tuneado-colores" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida tuneado + colores"><p>Juego de la vida tuneado + colores</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Tercera y última continuación espiritual de <a href="/blog/shaders-en-corto" title="null" class="text-primary [word-break:break-word]" target="_blank">shaders en corto</a>. Con este post me voy de vacaciones de los shaders. Probablemente los siga usando, pero no escribiré más posts enfocados en GLSL.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Un adelanto del resultado final:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex flex-col w-full"><img loading="lazy" class="w-auto h-80 object-contain bg-black bg-opacity-30" src="/blog/autmatas-celulares-en-glsl/img/automata.gif"><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Viendo la complejidad que tiene <a href="https://es.wikipedia.org/wiki/Lenia" title="null" class="text-primary [word-break:break-word]" target="_blank">Lenia</a> para ser implementado, en este post se experimentará específicamente haciendo una versión del juego de la vida más &quot;suave&quot; (ya existen btw).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Las reglas del juego de la vida se pueden encontrar en Wikipedia 🗿:</p>
<ul>
<li>Nace: Si una célula muerta tiene exactamente 3 células vecinas vivas &quot;nace&quot; (es decir, al turno siguiente estará viva).</li>
<li>Muere: una célula viva puede morir por uno de 2 casos:<ul>
<li>Sobrepoblación: si tiene más de tres vecinos alrededor.</li>
<li>Aislamiento: si tiene solo un vecino alrededor o ninguno.</li>
</ul>
</li>
<li>Vive: una célula se mantiene viva si tiene 2 o 3 vecinos a su alrededor.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="juego-de-la-vida-proporcional">Juego de la vida proporcional</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>El juego de la vida es algo determinante y el primer experimento es cambiar las reglas a algo más flexible. Las reglas quedarían así:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Siendo <code>n</code> la suma de la vida de los vecinos, la celda cambia respecto a <code>n</code> en los siguientes rangos:</p>
<ul>
<li><code>[0, 1]</code>: Vida disminuye en <code>n</code>.</li>
<li><code>[1, 3]</code>: Vida aumenta en <code>n/3</code>.</li>
<li><code>3 a más</code>: Vida disminuye en <code>n/8</code> (el máximo de <code>n</code> es 8).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Para ver la diferencia, se usará el siguiente estado inicial:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Y con las nuevas reglas:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Viene con trucos:</p>
<ul>
<li>Se cambió el rango de aumentar vida de <code>[1, 3]</code> a <code>[1, 1.5]</code>. Simplemente porque se ve mejor 👍. Se puede probar otros valores moviendo el slider, representa el <code>gap</code> para aumentar la vida. El máximo es 8, lo cual hace que crezca sin parar.</li>
<li>Esquinas redondeadas: Suponiendo que la distancia horizontal y vertical es de 1, la vida de las celdas diagonales se multiplicó por <code>1 / sqrt(2)</code> (solo se considera la vida proporcionalmente a la distancia horizontal y vertical).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Valores cercanos a 4 (como el del ejemplo) forman patrones rectos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="juego-de-la-vida-proporcional-y-zonal">Juego de la vida proporcional y zonal</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En este experimento se aumentará el área considerada para los vecinos. Con ello se tendrían 2 variables <code>gap</code> (que representa la formación de vida) y <code>r</code> (el radio considerado para los vecinos).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Las reglas ahora son, siendo <code>n</code> la suma de la vida de los vecinos, la celda cambia respecto a <code>n</code> en los siguientes rangos:</p>
<ul>
<li><code>[0, 1]</code>: Vida disminuye en <code>n</code>.</li>
<li><code>[1, gap]</code>: Vida aumenta en <code>n/gap</code>.</li>
<li><code>gap a más</code>: Vida disminuye en <code>n/totalN</code>.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>No hay una explicación &quot;lógica&quot; para <code>totalN</code>, solo se sigue la corriente de lo que se propuso antes con <code>1 / sqrt(2)</code> para las esquinas.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p><code>totalN</code>: Representa la suma de las distancias proporcionales de los vecinos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Por ejemplo:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(<span class="hljs-type">vec2</span>(i, j) - <span class="hljs-type">vec2</span>(k, l)); <span class="hljs-comment">// Distance de la celda evaluada (i, j) al vecino (k, l)</span>
<span class="hljs-type">float</span> factor = <span class="hljs-number">1.0</span> / dist; <span class="hljs-comment">// Variable propuesta</span>
<span class="hljs-type">float</span> curLive = getState(k, l) * factor;
n += curLive;
totalN += factor;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Dos puntos a tener en cuenta:</p>
<ul>
<li>El primer slider es el <code>gap</code> de vida y el segundo el radio <code>r</code> para considerar vecinos.</li>
<li>Se hizo upgrade a la versión de GLSL para usar las variables de los loops como índices (no es importante, solo quería mencionarlo).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="tunenado-el-juego-de-la-vida">Tunenado el juego de la vida</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En el experimente anterior se percibe un cambio drástico entre estados (por eso se redujo a 4 frames por segundo), a este punto solo se busca que se formen patrones más consistentes entre frames (ya ni se aplican las reglas propuestas previamente).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="live-ugap-n-n"><code>live += (uGap - n) * n</code></h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><ul>
<li>Primer slider: <code>gap</code></li>
<li>Segundo slider: Radio para considerar un vecino (<code>r</code>).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Hay muchos sacrilegios tomados para hacer que luzca genial 🙂. No deberían ser problema, el código principal es el siguiente:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">void</span> main() {
  <span class="hljs-type">float</span> i = vXY.x * uWidth - <span class="hljs-number">0.5</span>;
  <span class="hljs-type">float</span> j = uHeight - vXY.y * uHeight - <span class="hljs-number">0.5</span>;

  <span class="hljs-type">float</span> live = getState(i, j);

  <span class="hljs-type">float</span> n = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> r = <span class="hljs-number">1.0</span>; r &lt;= uR; r++) {
    <span class="hljs-type">float</span> <span class="hljs-keyword">points</span> = <span class="hljs-number">8.0</span> * r;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> p = <span class="hljs-number">0.0</span>; p &lt; <span class="hljs-keyword">points</span>; p++) {
      <span class="hljs-type">float</span> k = i + r * <span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span> * PI * p / <span class="hljs-keyword">points</span>);
      <span class="hljs-type">float</span> l = j + r * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span> * PI * p / <span class="hljs-keyword">points</span>);
      <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(<span class="hljs-type">vec2</span>(i, j) - <span class="hljs-type">vec2</span>(k, l));
      <span class="hljs-type">float</span> factor = <span class="hljs-number">100.0</span> / dist; <span class="hljs-comment">// 😉</span>
      <span class="hljs-type">float</span> klLive = getState(k, l) * factor;
      n += klLive;
    }
  }

  live += (uGap - n) * n;

  fragColor = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(live), <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>El factor tomó un papel importante, reduce el impacto de los vecinos más lejanos. El cálculo del nuevo estado se redujo a <code>live += (uGap - n) * n;</code>, se omitió el caso de aislamientos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Pero parece que no son suficientes cambios para ver una interacción más suave. Tiene el aspecto que hay mucha probabilidad de sobrevivir, pero el aspecto es más orgánico.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Con estos resultados se ven 2 oportunidades:</p>
<ul>
<li>Dar más posibilidad de sobrevivir a casos medios.</li>
<li>Se puede reducir las reglas a una fórmula para obtener patrones.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Una fórmula que me interesó mucho es la siguiente, da patrones más consistentes.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="live-n-logn-n-ugap"><code>live += -n * log(n) + n * uGap</code></h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Pero los cambios entre estados ahora son más fuerte fuertes (ósea se mueve más rápido). Por lo que hay que dar más chance a la muerte o reducir el impacto de los vecinos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="live-pown-ugap-20-ugap"><code>live += -pow(n - uGap, 2.0) + uGap</code></h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Después de rebuscar valores que generen patrones orgánicos, se encontró que con esta regla se pueden conseguir. Los valores son algo rebuscados pero se consiguió una función que representa bien un juego suave:</p>
<ul>
<li><a href="https://www.desmos.com/calculator/hzovhepzko" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://www.desmos.com/calculator/hzovhepzko</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Se dejó el factor en <code>float factor = 1.0 / dist;</code> (tiene más sentido) y los parámetros son los siguientes:</p>
<ul>
<li><code>gap</code>: 12.9</li>
<li><code>r</code>: 5</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Sin embargo, después de unas iteraciones el patrón se vuelve caótico. Aunque, ese inicio es un logro.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En este ejemplo se renderizan varios puntos aleatorios como estado inicial. Dale play (tanto como gustes 🙂) para ver distintos patrones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="juego-de-la-vida-tuneado-colores">Juego de la vida tuneado + colores</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Último experimento. Darle un poco de vida con colores. Podrían modificarse las reglas para generar distintos estados dependiendo del color y es justo lo que se muestra a continuación:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Ahora los patrones son más estables y quedan varias células autosuficientes. Los parámetros son:</p>
<ul>
<li><code>gap</code>: 13</li>
<li>Radio <code>r</code>: 5</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Se tienen 3 dimensiones por celda. Se calculan vecinos por cada dimension, por lo que <code>n</code> ahora es un <code>vec3</code>. La interacción en este caso es pasar una dimensión distinta para el cálculo de la celda evaluada:</p>
<pre><code class="hljs language-glsl">live.r += -<span class="hljs-built_in">pow</span>(n.b - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.g += -<span class="hljs-built_in">pow</span>(n.r - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.b += -<span class="hljs-built_in">pow</span>(n.g - uGap, <span class="hljs-number">2.0</span>) + uGap;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Algo a notar es que hay patrones de expansión rectos, esto es por el cálculo de la vida en la vecindad. Se usan coordenadas polares, se da una vuelta y se va ampliando el radio. El problema está en la cantidad de puntos que se evalúan por radio, como se muestra:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> <span class="hljs-keyword">points</span> = <span class="hljs-number">8.0</span> * r;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Aumentando la cantidad de puntos por radio requiere buscar otros parámetros, pero esto mejora en la estabilidad de los patrones:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><ul>
<li><code>gap</code>: 17.5</li>
<li><code>r</code>: 4</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Para estabilizar los colores se puede hacer más dependiente a cada dimensión de las demás, un buen patron encontrado es el siguiente:</p>
<pre><code class="hljs language-glsl">live.r += -<span class="hljs-built_in">pow</span>((n.r) / <span class="hljs-number">2.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.g += -<span class="hljs-built_in">pow</span>((n.r + n.g) / <span class="hljs-number">3.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.b += -<span class="hljs-built_in">pow</span>((n.r + n.g + n.b) / <span class="hljs-number">4.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Ejecútalo varias veces, se obtienen patrones bastante suaves pero hay momentos caóticos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Nota final:</p>
<p>Muchos de los cálculos desde <em>tunear</em> son buscados al ojo. Son experimentos para pasar el rato (uno bueno). Si tienes alguna propuesta, feliz de escucharla o probarla!</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Recursos:</p>
<ul>
<li><a href="/blog/shaders-en-corto" title="null" class="text-primary [word-break:break-word]" target="_blank">Shaders en corto</a></li>
<li><a href="https://es.wikipedia.org/wiki/Juego_de_la_vida" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://es.wikipedia.org/wiki/Juego_de_la_vida</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>No puedo terminar sin antes recrear el primer ejemplo con el nuevo autómata creado!</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Por esta ocasión pondré todo el código aquí (siempre está disponible inspeccionando el iframe), puedes pegarlo y editarlo aquí:</p>
<ul>
<li><a href="https://editor.p5js.org/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><pre><code class="hljs language-js">p5.<span class="hljs-property">RendererGL</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_initContext</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span> =
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;webgl2&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pInst</span>.<span class="hljs-property">_glAttributes</span>) ||
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;experimental-webgl&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pInst</span>.<span class="hljs-property">_glAttributes</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error creating webgl context&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>;
      gl.<span class="hljs-title function_">enable</span>(gl.<span class="hljs-property">DEPTH_TEST</span>);
      gl.<span class="hljs-title function_">depthFunc</span>(gl.<span class="hljs-property">LEQUAL</span>);
      gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, gl.<span class="hljs-property">drawingBufferWidth</span>, gl.<span class="hljs-property">drawingBufferHeight</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_viewport</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>.<span class="hljs-title function_">getParameter</span>(
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>.<span class="hljs-property">VIEWPORT</span>
      );
    }
  } <span class="hljs-keyword">catch</span> (er) {
    <span class="hljs-keyword">throw</span> er;
  }
};

<span class="hljs-keyword">const</span> vertShader = <span class="hljs-string">`#version 300 es
in vec3 aPosition;
out vec2 vXY;
void main() {
  vec4 pos = vec4(aPosition, 1.0);
  vXY = pos.xy;
  pos = pos * 2.0 - 1.0;
  gl_Position = pos;
}`</span>;

<span class="hljs-keyword">const</span> fragShader = <span class="hljs-string">`#version 300 es
precision mediump float;
in vec2 vXY;
uniform float uWidth;
uniform float uHeight;
uniform float uR;
uniform float uLGap;
uniform float uGap;
uniform sampler2D uState;
uniform vec2 uCircle;
out vec4 fragColor;
const float PI = 3.14159264;

vec3 getState(float i, float j) {
  vec4 data = texture(
    uState,
    vec2(
      (i + 0.5) / uWidth,
      (j + 0.5) / uHeight
    )
  );
  return data.rgb;
}

void main() {
  float i = vXY.x * uWidth - 0.5;
  float j = uHeight - vXY.y * uHeight - 0.5;

  vec3 live = getState(i, j);

  vec3 n = vec3(0.0);
  for(float r = 1.0; r &lt;= uR; r++) {
    float points = 16.0 * r;
    for(float p = 0.0; p &lt; points; p++) {
      float k = i + r * cos(2.0 * PI * p / points);
      float l = j + r * sin(2.0 * PI * p / points);
      float dist = length(vec2(i, j) - vec2(k, l));
      float factor = 1.0 / dist;
      vec3 klLive = getState(k, l) * factor;
      n.r += klLive.r;
      n.g += klLive.g;
      n.b += klLive.b;
    }
  }

  vec2 pos = (vXY * 2.0 - 1.0);
  pos.x *= (uWidth / uHeight);
  float circleDist = length(pos - uCircle);
  
  if(circleDist &lt; 0.1) {
    live = vec3(1.0);
  } else {
    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;
    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;
    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;
  }

  fragColor = vec4(live, 1.0);
}
`</span>;

<span class="hljs-keyword">let</span> myShader;
<span class="hljs-keyword">let</span> g;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">350</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
  g = <span class="hljs-title function_">createGraphics</span>(<span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
  myShader = <span class="hljs-title function_">createShader</span>(vertShader, fragShader);

  g.<span class="hljs-title function_">shader</span>(myShader);
  g.<span class="hljs-title function_">stroke</span>(<span class="hljs-number">255</span>);
  g.<span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restart</span>(<span class="hljs-params"></span>) {
    g.<span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">const</span> points = <span class="hljs-number">3000</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= points; i++) {
      <span class="hljs-keyword">const</span> x = width * (<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">const</span> y = height * (<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
      g.<span class="hljs-title function_">stroke</span>(<span class="hljs-title function_">color</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>), <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>), <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>)));
      g.<span class="hljs-title function_">point</span>(x, y);
    }

    <span class="hljs-title function_">imageMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">image</span>(g, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
  }

  <span class="hljs-title function_">restart</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> angle = frameCount / <span class="hljs-number">80</span>;
  <span class="hljs-keyword">const</span> uCircle = [<span class="hljs-title function_">cos</span>(angle) * <span class="hljs-number">0.6</span>, <span class="hljs-title function_">sin</span>(angle) * <span class="hljs-number">0.6</span>];
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uState&quot;</span>, g);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uCircle&quot;</span>, uCircle);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uR&quot;</span>, <span class="hljs-number">5</span>);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uGap&quot;</span>, <span class="hljs-number">13.7</span>);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uWidth&quot;</span>, width);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uHeight&quot;</span>, height);
  g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-title function_">imageMode</span>(<span class="hljs-variable constant_">CENTER</span>);
  <span class="hljs-title function_">image</span>(g, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
}
</code></pre></div></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html> 