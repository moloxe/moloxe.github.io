<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Aut칩matas celulares en GLSL"><meta name="twitter:title" content="Aut칩matas celulares en GLSL"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #edu #art"><meta property="og:description" content="Tags: #tech #edu #art"><meta name="twitter:description" content="Tags: #tech #edu #art"><meta property="og:image" content="https://moloxe.github.io/blog/autmatas-celulares-en-glsl/img/automata.gif"><meta name="twitter:image" content="https://moloxe.github.io/blog/autmatas-celulares-en-glsl/img/automata.gif"><meta name="generator" content="Astro v5.16.9"><title>Aut칩matas celulares en GLSL</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.CDGfc0hd.js"></script><link rel="stylesheet" href="/_astro/ants-test.yXysTIuy.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.0BedYp8Q.js" component-export="default" renderer-url="/_astro/client.BZ2AD0De.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-sm font-mono px-4 pt-2 pb-8 text-neutral-400 leading-5 break-all max-sm:text-xs max-sm:pb-4 max-sm:px-2"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/autmatas-celulares-en-glsl" class="hover:text-white">autmatas-celulares-en-glsl</a>  </p>  <div class="font-extralight font-mono flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="ZThXoz" prefix="s0" component-url="/_astro/PostView.Cg2cuyrR.js" component-export="default" renderer-url="/_astro/client.BZ2AD0De.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Aut칩matas celulares en GLSL&quot;],&quot;creationDate&quot;:[3,&quot;2024-06-23T23:08:25.980Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2024-09-02T05:07:28.136Z&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;edu&quot;],[0,&quot;art&quot;]]],&quot;container&quot;:[1,[[0,{&quot;text&quot;:[0,&quot;Tercera y 칰ltima continuaci칩n espiritual de [shaders en corto](/blog/shaders-en-corto). Con este post me voy de vacaciones de los shaders. Probablemente los siga usando, pero no escribir칠 m치s posts enfocados en GLSL.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Un adelanto del resultado final:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;/automata.gif&quot;],&quot;type&quot;:[0,&quot;ImageBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Viendo la complejidad que tiene [Lenia](https://es.wikipedia.org/wiki/Lenia) para ser implementado, en este post se experimentar치 espec칤ficamente haciendo una versi칩n del juego de la vida m치s \&quot;suave\&quot; (ya existen btw).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist &lt; 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i &lt; uStateSize; i++) {\\n    for (let j = 0; j &lt; uStateSize; j++) {\\n      if (random(1) &gt; 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Las reglas del juego de la vida se pueden encontrar en Wikipedia 游:\n- Nace: Si una c칠lula muerta tiene exactamente 3 c칠lulas vecinas vivas \&quot;nace\&quot; (es decir, al turno siguiente estar치 viva).\n- Muere: una c칠lula viva puede morir por uno de 2 casos:\n  - Sobrepoblaci칩n: si tiene m치s de tres vecinos alrededor.\n  - Aislamiento: si tiene solo un vecino alrededor o ninguno.\n- Vive: una c칠lula se mantiene viva si tiene 2 o 3 vecinos a su alrededor.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida proporcional&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El juego de la vida es algo determinante y el primer experimento es cambiar las reglas a algo m치s flexible. Las reglas quedar칤an as칤:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, 3]`: Vida aumenta en `n/3`.\n- `3 a m치s`: Vida disminuye en `n/8` (el m치ximo de `n` es 8).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para ver la diferencia, se usar치 el siguiente estado inicial:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  const points = 50;\\n  for (let i = 0; i &lt; points; i++) {\\n    const x = 50 * cos((TWO_PI * i) / points);\\n    const y = 50 * sin((TWO_PI * i) / points);\\n    g.point(x, y);\\n  }\\n\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n  frameRate(14);\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Y con las nuevas reglas:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float uGap;\\nuniform sampler2D uState;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  float live = getState(i, j);\\n  float tl = getState(i - 1, j - 1);\\n  float t = getState(i, j - 1);\\n  float tr = getState(i + 1, j - 1);\\n  float l = getState(i - 1, j);\\n  float r = getState(i + 1, j);\\n  float bl = getState(i - 1, j + 1);\\n  float b = getState(i, j + 1);\\n  float br = getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(n &lt;= 1.0) {\\n    live -= n;\\n  } else if(n &lt;= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / 8.0;\\n  }\\n\\n  gl_FragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\n\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt; points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() =&gt; {\\n    restart();\\n  });\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Viene con trucos:\n- Se cambi칩 el rango de aumentar vida de `[1, 3]` a `[1, 1.5]`. Simplemente porque se ve mejor 游녨. Se puede probar otros valores moviendo el slider, representa el `gap` para aumentar la vida. El m치ximo es 8, lo cual hace que crezca sin parar.\n- Esquinas redondeadas: Suponiendo que la distancia horizontal y vertical es de 1, la vida de las celdas diagonales se multiplic칩 por `1 / sqrt(2)` (solo se considera la vida proporcionalmente a la distancia horizontal y vertical).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Valores cercanos a 4 (como el del ejemplo) forman patrones rectos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida proporcional y zonal&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En este experimento se aumentar치 el 치rea considerada para los vecinos. Con ello se tendr칤an 2 variables `gap` (que representa la formaci칩n de vida) y `r` (el radio considerado para los vecinos).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Las reglas ahora son, siendo `n` la suma de la vida de los vecinos, la celda cambia respecto a `n` en los siguientes rangos:\n- `[0, 1]`: Vida disminuye en `n`.\n- `[1, gap]`: Vida aumenta en `n/gap`.\n- `gap a m치s`: Vida disminuye en `n/totalN`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No hay una explicaci칩n \&quot;l칩gica\&quot; para `totalN`, solo se sigue la corriente de lo que se propuso antes con `1 / sqrt(2)` para las esquinas.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`totalN`: Representa la suma de las distancias proporcionales de los vecinos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Por ejemplo:\n```glsl\nfloat dist = length(vec2(i, j) - vec2(k, l)); // Distance de la celda evaluada (i, j) al vecino (k, l)\nfloat factor = 1.0 / dist; // Variable propuesta\nfloat curLive = getState(k, l) * factor;\nn += curLive;\ntotalN += factor;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  float totalN = 0.0;\\n  for(float k = i - uR; k &lt;= i + uR; k++) {\\n    for(float l = j - uR; l &lt;= j + uR; l++) {\\n      if(i == k &amp;&amp; j == l) continue;\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float curLive = getState(k, l) * factor;\\n      n += curLive;\\n      totalN += factor;\\n    }\\n  }\\n\\n  if(n &lt;= 1.0) {\\n    live -= n;\\n  } else if(n &lt;= uGap) {\\n    live += n / uGap;\\n  } else {\\n    live -= n / totalN;\\n  }\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 8, 3.0, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 4, 1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt; points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(() =&gt; {\\n    restart();\\n  });\\n  rSlider.input(() =&gt; {\\n    restart();\\n  });\\n  restart();\\n\\n  frameRate(4);\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Dos puntos a tener en cuenta:\n- El primer slider es el `gap` de vida y el segundo el radio `r` para considerar vecinos.\n- Se hizo upgrade a la versi칩n de GLSL para usar las variables de los loops como 칤ndices (no es importante, solo quer칤a mencionarlo).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Tunenado el juego de la vida&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el experimente anterior se percibe un cambio dr치stico entre estados (por eso se redujo a 4 frames por segundo), a este punto solo se busca que se formen patrones m치s consistentes entre frames (ya ni se aplican las reglas propuestas previamente).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## `live += (uGap - n) * n`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // :D\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  float change = (uGap - n) * n;\\n  live += change;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 10, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- Primer slider: `gap`\n- Segundo slider: Radio para considerar un vecino (`r`). &quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Hay muchos sacrilegios tomados para hacer que luzca genial 游뗵. No deber칤an ser problema, el c칩digo principal es el siguiente:\n\n```glsl\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  float live = getState(i, j);\n\n  float n = 0.0;\n  for(float r = 1.0; r &lt;= uR; r++) {\n    float points = 8.0 * r;\n    for(float p = 0.0; p &lt; points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 100.0 / dist; // 游땔\n      float klLive = getState(k, l) * factor;\n      n += klLive;\n    }\n  }\n\n  live += (uGap - n) * n;\n\n  fragColor = vec4(vec3(live), 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El factor tom칩 un papel importante, reduce el impacto de los vecinos m치s lejanos. El c치lculo del nuevo estado se redujo a `live += (uGap - n) * n;`, se omiti칩 el caso de aislamientos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pero parece que no son suficientes cambios para ver una interacci칩n m치s suave. Tiene el aspecto que hay mucha probabilidad de sobrevivir, pero el aspecto es m치s org치nico.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Con estos resultados se ven 2 oportunidades:\n- Dar m치s posibilidad de sobrevivir a casos medios.\n- Se puede reducir las reglas a una f칩rmula para obtener patrones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Una f칩rmula que me interes칩 mucho es la siguiente, da patrones m치s consistentes.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## `live += -n * log(n) + n * uGap`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 100.0 / dist; // 游땔\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n\\n  live += -n * log(n) + n * uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 10, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pero los cambios entre estados ahora son m치s fuerte fuertes (칩sea se mueve m치s r치pido). Por lo que hay que dar m치s chance a la muerte o reducir el impacto de los vecinos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# `live += -pow(n - uGap, 2.0) + uGap`&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Despu칠s de rebuscar valores que generen patrones org치nicos, se encontr칩 que con esta regla se pueden conseguir. Los valores son algo rebuscados pero se consigui칩 una funci칩n que representa bien un juego suave:\n- https://www.desmos.com/calculator/hzovhepzko&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 12.9, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 50;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = 50 * cos((TWO_PI * i) / points);\\n      const y = 50 * sin((TWO_PI * i) / points);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se dej칩 el factor en `float factor = 1.0 / dist;` (tiene m치s sentido) y los par치metros son los siguientes:\n- `gap`: 12.9\n- `r`: 5&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Sin embargo, despu칠s de unas iteraciones el patr칩n se vuelve ca칩tico. Aunque, ese inicio es un logro.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nfloat getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.g;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  float live = getState(i, j);\\n\\n  float n = 0.0;\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      float klLive = getState(k, l) * factor;\\n      n += klLive;\\n    }\\n  }\\n  \\n  live += -pow(n - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 18, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 8, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En este ejemplo se renderizan varios puntos aleatorios como estado inicial. Dale play (tanto como gustes 游뗵) para ver distintos patrones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Juego de la vida tuneado + colores&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;칔ltimo experimento. Darle un poco de vida con colores. Podr칤an modificarse las reglas para generar distintos estados dependiendo del color y es justo lo que se muestra a continuaci칩n:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 8.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Ahora los patrones son m치s estables y quedan varias c칠lulas autosuficientes. Los par치metros son:\n- `gap`: 13\n- Radio `r`: 5&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se tienen 3 dimensiones por celda. Se calculan vecinos por cada dimension, por lo que `n` ahora es un `vec3`. La interacci칩n en este caso es pasar una dimensi칩n distinta para el c치lculo de la celda evaluada:\n\n```glsl\nlive.r += -pow(n.b - uGap, 2.0) + uGap;\nlive.g += -pow(n.r - uGap, 2.0) + uGap;\nlive.b += -pow(n.g - uGap, 2.0) + uGap;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Algo a notar es que hay patrones de expansi칩n rectos, esto es por el c치lculo de la vida en la vecindad. Se usan coordenadas polares, se da una vuelta y se va ampliando el radio. El problema est치 en la cantidad de puntos que se eval칰an por radio, como se muestra:\n\n```glsl\nfloat points = 8.0 * r;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Aumentando la cantidad de puntos por radio requiere buscar otros par치metros, pero esto mejora en la estabilidad de los patrones:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow(n.b - uGap, 2.0) + uGap;\\n  live.g += -pow(n.r - uGap, 2.0) + uGap;\\n  live.b += -pow(n.g - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 17.5, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 4, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- `gap`: 17.5\n- `r`: 4&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para estabilizar los colores se puede hacer m치s dependiente a cada dimensi칩n de las dem치s, un buen patron encontrado es el siguiente:\n\n```glsl\nlive.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\nlive.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\nlive.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n  \\n  live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n  live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n  live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n\\n  fragColor = vec4(vec3(live), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nlet gapSlider;\\nlet rSlider;\\n\\nfunction setup() {\\n  createCanvas(320, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  gapSlider = createSlider(0, 20, 13.4, 0.1);\\n  gapSlider.position(10, 10);\\n  gapSlider.size(100);\\n\\n  rSlider = createSlider(1, 20, 5, 0.1);\\n  rSlider.position(10, 30);\\n  rSlider.size(100);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  gapSlider.input(restart);\\n  rSlider.input(restart);\\n  restart();\\n}\\n\\nfunction draw() {\\n  const gap = gapSlider.value();\\n  const r = rSlider.value();\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, r);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, gap);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Ejec칰talo varias veces, se obtienen patrones bastante suaves pero hay momentos ca칩ticos.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota final:\n\nMuchos de los c치lculos desde *tunear* son buscados al ojo. Son experimentos para pasar el rato (uno bueno). Si tienes alguna propuesta, feliz de escucharla o probarla!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Recursos:\n- [Shaders en corto](/blog/shaders-en-corto)\n- https://es.wikipedia.org/wiki/Juego_de_la_vida&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No puedo terminar sin antes recrear el primer ejemplo con el nuevo aut칩mata creado!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;p5.RendererGL.prototype._initContext = function () {\\n  try {\\n    this.drawingContext =\\n      this.canvas.getContext(\\\&quot;webgl2\\\&quot;, this._pInst._glAttributes) ||\\n      this.canvas.getContext(\\\&quot;experimental-webgl\\\&quot;, this._pInst._glAttributes);\\n    if (this.drawingContext === null) {\\n      throw new Error(\\\&quot;Error creating webgl context\\\&quot;);\\n    } else {\\n      const gl = this.drawingContext;\\n      gl.enable(gl.DEPTH_TEST);\\n      gl.depthFunc(gl.LEQUAL);\\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\\n      this._viewport = this.drawingContext.getParameter(\\n        this.drawingContext.VIEWPORT\\n      );\\n    }\\n  } catch (er) {\\n    throw er;\\n  }\\n};\\n\\nconst vertShader = `#version 300 es\\nin vec3 aPosition;\\nout vec2 vXY;\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}`;\\n\\nconst fragShader = `#version 300 es\\nprecision mediump float;\\nin vec2 vXY;\\nuniform float uWidth;\\nuniform float uHeight;\\nuniform float uR;\\nuniform float uLGap;\\nuniform float uGap;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nout vec4 fragColor;\\nconst float PI = 3.14159264;\\n\\nvec3 getState(float i, float j) {\\n  vec4 data = texture(\\n    uState,\\n    vec2(\\n      (i + 0.5) / uWidth,\\n      (j + 0.5) / uHeight\\n    )\\n  );\\n  return data.rgb;\\n}\\n\\nvoid main() {\\n  float i = vXY.x * uWidth - 0.5;\\n  float j = uHeight - vXY.y * uHeight - 0.5;\\n\\n  vec3 live = getState(i, j);\\n\\n  vec3 n = vec3(0.0);\\n  for(float r = 1.0; r &lt;= uR; r++) {\\n    float points = 16.0 * r;\\n    for(float p = 0.0; p &lt; points; p++) {\\n      float k = i + r * cos(2.0 * PI * p / points);\\n      float l = j + r * sin(2.0 * PI * p / points);\\n      float dist = length(vec2(i, j) - vec2(k, l));\\n      float factor = 1.0 / dist;\\n      vec3 klLive = getState(k, l) * factor;\\n      n.r += klLive.r;\\n      n.g += klLive.g;\\n      n.b += klLive.b;\\n    }\\n  }\\n\\n  vec2 pos = (vXY * 2.0 - 1.0);\\n  pos.x *= (uWidth / uHeight);\\n  float circleDist = length(pos - uCircle);\\n  \\n  if(circleDist &lt; 0.1) {\\n    live = vec3(1.0);\\n  } else {\\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\\n  }\\n\\n  fragColor = vec4(live, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\n\\nfunction setup() {\\n  createCanvas(350, 320, WEBGL);\\n  g = createGraphics(320, 320, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n\\n  g.shader(myShader);\\n  g.stroke(255);\\n  g.fill(255);\\n\\n  function restart() {\\n    g.background(0);\\n\\n    const points = 3000;\\n    for (let i = 0; i &lt;= points; i++) {\\n      const x = width * (random(2) - 1);\\n      const y = height * (random(2) - 1);\\n      g.stroke(color(random(255), random(255), random(255)));\\n      g.point(x, y);\\n    }\\n\\n    imageMode(CENTER);\\n    image(g, 0, 0, width, height);\\n  }\\n\\n  restart();\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  myShader.setUniform(\\\&quot;uR\\\&quot;, 5);\\n  myShader.setUniform(\\\&quot;uGap\\\&quot;, 13.7);\\n  myShader.setUniform(\\\&quot;uWidth\\\&quot;, width);\\n  myShader.setUniform(\\\&quot;uHeight\\\&quot;, height);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Por esta ocasi칩n pondr칠 todo el c칩digo aqu칤 (siempre est치 disponible inspeccionando el iframe), puedes pegarlo y editarlo aqu칤:\n- https://editor.p5js.org/&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;```js\np5.RendererGL.prototype._initContext = function () {\n  try {\n    this.drawingContext =\n      this.canvas.getContext(\&quot;webgl2\&quot;, this._pInst._glAttributes) ||\n      this.canvas.getContext(\&quot;experimental-webgl\&quot;, this._pInst._glAttributes);\n    if (this.drawingContext === null) {\n      throw new Error(\&quot;Error creating webgl context\&quot;);\n    } else {\n      const gl = this.drawingContext;\n      gl.enable(gl.DEPTH_TEST);\n      gl.depthFunc(gl.LEQUAL);\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      this._viewport = this.drawingContext.getParameter(\n        this.drawingContext.VIEWPORT\n      );\n    }\n  } catch (er) {\n    throw er;\n  }\n};\n\nconst vertShader = `#version 300 es\nin vec3 aPosition;\nout vec2 vXY;\nvoid main() {\n  vec4 pos = vec4(aPosition, 1.0);\n  vXY = pos.xy;\n  pos = pos * 2.0 - 1.0;\n  gl_Position = pos;\n}`;\n\nconst fragShader = `#version 300 es\nprecision mediump float;\nin vec2 vXY;\nuniform float uWidth;\nuniform float uHeight;\nuniform float uR;\nuniform float uLGap;\nuniform float uGap;\nuniform sampler2D uState;\nuniform vec2 uCircle;\nout vec4 fragColor;\nconst float PI = 3.14159264;\n\nvec3 getState(float i, float j) {\n  vec4 data = texture(\n    uState,\n    vec2(\n      (i + 0.5) / uWidth,\n      (j + 0.5) / uHeight\n    )\n  );\n  return data.rgb;\n}\n\nvoid main() {\n  float i = vXY.x * uWidth - 0.5;\n  float j = uHeight - vXY.y * uHeight - 0.5;\n\n  vec3 live = getState(i, j);\n\n  vec3 n = vec3(0.0);\n  for(float r = 1.0; r &lt;= uR; r++) {\n    float points = 16.0 * r;\n    for(float p = 0.0; p &lt; points; p++) {\n      float k = i + r * cos(2.0 * PI * p / points);\n      float l = j + r * sin(2.0 * PI * p / points);\n      float dist = length(vec2(i, j) - vec2(k, l));\n      float factor = 1.0 / dist;\n      vec3 klLive = getState(k, l) * factor;\n      n.r += klLive.r;\n      n.g += klLive.g;\n      n.b += klLive.b;\n    }\n  }\n\n  vec2 pos = (vXY * 2.0 - 1.0);\n  pos.x *= (uWidth / uHeight);\n  float circleDist = length(pos - uCircle);\n  \n  if(circleDist &lt; 0.1) {\n    live = vec3(1.0);\n  } else {\n    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;\n    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;\n    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;\n  }\n\n  fragColor = vec4(live, 1.0);\n}\n`;\n\nlet myShader;\nlet g;\n\nfunction setup() {\n  createCanvas(350, 320, WEBGL);\n  g = createGraphics(320, 320, WEBGL);\n  myShader = createShader(vertShader, fragShader);\n\n  g.shader(myShader);\n  g.stroke(255);\n  g.fill(255);\n\n  function restart() {\n    g.background(0);\n\n    const points = 3000;\n    for (let i = 0; i &lt;= points; i++) {\n      const x = width * (random(2) - 1);\n      const y = height * (random(2) - 1);\n      g.stroke(color(random(255), random(255), random(255)));\n      g.point(x, y);\n    }\n\n    imageMode(CENTER);\n    image(g, 0, 0, width, height);\n  }\n\n  restart();\n}\n\nfunction draw() {\n  const angle = frameCount / 80;\n  const uCircle = [cos(angle) * 0.6, sin(angle) * 0.6];\n  myShader.setUniform(\&quot;uState\&quot;, g);\n  myShader.setUniform(\&quot;uCircle\&quot;, uCircle);\n  myShader.setUniform(\&quot;uR\&quot;, 5);\n  myShader.setUniform(\&quot;uGap\&quot;, 13.7);\n  myShader.setUniform(\&quot;uWidth\&quot;, width);\n  myShader.setUniform(\&quot;uHeight\&quot;, height);\n  g.rect(0, 0, 0, 0);\n  imageMode(CENTER);\n  image(g, 0, 0, width, height);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}]]],&quot;isPinned&quot;:[0,false],&quot;slugUrl&quot;:[0,&quot;autmatas-celulares-en-glsl&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Junio 23, 2024</div><p class="text-neutral-400 text-xs flex gap-1">7 minutos de lectura </p></div><h1>Aut칩matas celulares en GLSL</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">칈ndice:</h2><div><!----><ul><!--[--><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-proporcional" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida proporcional"><p>Juego de la vida proporcional</p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-proporcional-y-zonal" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida proporcional y zonal"><p>Juego de la vida proporcional y zonal</p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#tunenado-el-juego-de-la-vida" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Tunenado el juego de la vida"><p>Tunenado el juego de la vida</p>
</a><ul><!--[--><li><a href="/blog/autmatas-celulares-en-glsl/#live-ugap-n-n" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += (uGap - n) * n`"><p><code>live += (uGap - n) * n</code></p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#live-n-logn-n-ugap" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += -n * log(n) + n * uGap`"><p><code>live += -n * log(n) + n * uGap</code></p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/autmatas-celulares-en-glsl/#live-pown-ugap-20-ugap" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="`live += -pow(n - uGap, 2.0) + uGap`"><p><code>live += -pow(n - uGap, 2.0) + uGap</code></p>
</a><!----></li><li><a href="/blog/autmatas-celulares-en-glsl/#juego-de-la-vida-tuneado-colores" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Juego de la vida tuneado + colores"><p>Juego de la vida tuneado + colores</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Tercera y 칰ltima continuaci칩n espiritual de <a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a>. Con este post me voy de vacaciones de los shaders. Probablemente los siga usando, pero no escribir칠 m치s posts enfocados en GLSL.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Un adelanto del resultado final:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex flex-col w-full"><img loading="lazy" class="w-auto h-80 object-contain bg-black bg-opacity-30" src="/blog/autmatas-celulares-en-glsl/img/automata.gif"><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Viendo la complejidad que tiene <a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a> para ser implementado, en este post se experimentar치 espec칤ficamente haciendo una versi칩n del juego de la vida m치s &quot;suave&quot; (ya existen btw).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Las reglas del juego de la vida se pueden encontrar en Wikipedia 游:</p>
<ul>
<li>Nace: Si una c칠lula muerta tiene exactamente 3 c칠lulas vecinas vivas &quot;nace&quot; (es decir, al turno siguiente estar치 viva).</li>
<li>Muere: una c칠lula viva puede morir por uno de 2 casos:<ul>
<li>Sobrepoblaci칩n: si tiene m치s de tres vecinos alrededor.</li>
<li>Aislamiento: si tiene solo un vecino alrededor o ninguno.</li>
</ul>
</li>
<li>Vive: una c칠lula se mantiene viva si tiene 2 o 3 vecinos a su alrededor.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="juego-de-la-vida-proporcional">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>El juego de la vida es algo determinante y el primer experimento es cambiar las reglas a algo m치s flexible. Las reglas quedar칤an as칤:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Siendo <code>n</code> la suma de la vida de los vecinos, la celda cambia respecto a <code>n</code> en los siguientes rangos:</p>
<ul>
<li><code>[0, 1]</code>: Vida disminuye en <code>n</code>.</li>
<li><code>[1, 3]</code>: Vida aumenta en <code>n/3</code>.</li>
<li><code>3 a m치s</code>: Vida disminuye en <code>n/8</code> (el m치ximo de <code>n</code> es 8).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Para ver la diferencia, se usar치 el siguiente estado inicial:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Y con las nuevas reglas:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Viene con trucos:</p>
<ul>
<li>Se cambi칩 el rango de aumentar vida de <code>[1, 3]</code> a <code>[1, 1.5]</code>. Simplemente porque se ve mejor 游녨. Se puede probar otros valores moviendo el slider, representa el <code>gap</code> para aumentar la vida. El m치ximo es 8, lo cual hace que crezca sin parar.</li>
<li>Esquinas redondeadas: Suponiendo que la distancia horizontal y vertical es de 1, la vida de las celdas diagonales se multiplic칩 por <code>1 / sqrt(2)</code> (solo se considera la vida proporcionalmente a la distancia horizontal y vertical).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Valores cercanos a 4 (como el del ejemplo) forman patrones rectos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="juego-de-la-vida-proporcional-y-zonal">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En este experimento se aumentar치 el 치rea considerada para los vecinos. Con ello se tendr칤an 2 variables <code>gap</code> (que representa la formaci칩n de vida) y <code>r</code> (el radio considerado para los vecinos).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Las reglas ahora son, siendo <code>n</code> la suma de la vida de los vecinos, la celda cambia respecto a <code>n</code> en los siguientes rangos:</p>
<ul>
<li><code>[0, 1]</code>: Vida disminuye en <code>n</code>.</li>
<li><code>[1, gap]</code>: Vida aumenta en <code>n/gap</code>.</li>
<li><code>gap a m치s</code>: Vida disminuye en <code>n/totalN</code>.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>No hay una explicaci칩n &quot;l칩gica&quot; para <code>totalN</code>, solo se sigue la corriente de lo que se propuso antes con <code>1 / sqrt(2)</code> para las esquinas.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p><code>totalN</code>: Representa la suma de las distancias proporcionales de los vecinos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Por ejemplo:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(<span class="hljs-type">vec2</span>(i, j) - <span class="hljs-type">vec2</span>(k, l)); <span class="hljs-comment">// Distance de la celda evaluada (i, j) al vecino (k, l)</span>
<span class="hljs-type">float</span> factor = <span class="hljs-number">1.0</span> / dist; <span class="hljs-comment">// Variable propuesta</span>
<span class="hljs-type">float</span> curLive = getState(k, l) * factor;
n += curLive;
totalN += factor;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Dos puntos a tener en cuenta:</p>
<ul>
<li>El primer slider es el <code>gap</code> de vida y el segundo el radio <code>r</code> para considerar vecinos.</li>
<li>Se hizo upgrade a la versi칩n de GLSL para usar las variables de los loops como 칤ndices (no es importante, solo quer칤a mencionarlo).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="tunenado-el-juego-de-la-vida">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En el experimente anterior se percibe un cambio dr치stico entre estados (por eso se redujo a 4 frames por segundo), a este punto solo se busca que se formen patrones m치s consistentes entre frames (ya ni se aplican las reglas propuestas previamente).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="live-ugap-n-n">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><ul>
<li>Primer slider: <code>gap</code></li>
<li>Segundo slider: Radio para considerar un vecino (<code>r</code>).</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Hay muchos sacrilegios tomados para hacer que luzca genial 游뗵. No deber칤an ser problema, el c칩digo principal es el siguiente:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">void</span> main() {
  <span class="hljs-type">float</span> i = vXY.x * uWidth - <span class="hljs-number">0.5</span>;
  <span class="hljs-type">float</span> j = uHeight - vXY.y * uHeight - <span class="hljs-number">0.5</span>;

  <span class="hljs-type">float</span> live = getState(i, j);

  <span class="hljs-type">float</span> n = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> r = <span class="hljs-number">1.0</span>; r &lt;= uR; r++) {
    <span class="hljs-type">float</span> <span class="hljs-keyword">points</span> = <span class="hljs-number">8.0</span> * r;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> p = <span class="hljs-number">0.0</span>; p &lt; <span class="hljs-keyword">points</span>; p++) {
      <span class="hljs-type">float</span> k = i + r * <span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span> * PI * p / <span class="hljs-keyword">points</span>);
      <span class="hljs-type">float</span> l = j + r * <span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span> * PI * p / <span class="hljs-keyword">points</span>);
      <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(<span class="hljs-type">vec2</span>(i, j) - <span class="hljs-type">vec2</span>(k, l));
      <span class="hljs-type">float</span> factor = <span class="hljs-number">100.0</span> / dist; <span class="hljs-comment">// 游땔</span>
      <span class="hljs-type">float</span> klLive = getState(k, l) * factor;
      n += klLive;
    }
  }

  live += (uGap - n) * n;

  fragColor = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(live), <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>El factor tom칩 un papel importante, reduce el impacto de los vecinos m치s lejanos. El c치lculo del nuevo estado se redujo a <code>live += (uGap - n) * n;</code>, se omiti칩 el caso de aislamientos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Pero parece que no son suficientes cambios para ver una interacci칩n m치s suave. Tiene el aspecto que hay mucha probabilidad de sobrevivir, pero el aspecto es m치s org치nico.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Con estos resultados se ven 2 oportunidades:</p>
<ul>
<li>Dar m치s posibilidad de sobrevivir a casos medios.</li>
<li>Se puede reducir las reglas a una f칩rmula para obtener patrones.</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Una f칩rmula que me interes칩 mucho es la siguiente, da patrones m치s consistentes.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="live-n-logn-n-ugap">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Pero los cambios entre estados ahora son m치s fuerte fuertes (칩sea se mueve m치s r치pido). Por lo que hay que dar m치s chance a la muerte o reducir el impacto de los vecinos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="live-pown-ugap-20-ugap">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Despu칠s de rebuscar valores que generen patrones org치nicos, se encontr칩 que con esta regla se pueden conseguir. Los valores son algo rebuscados pero se consigui칩 una funci칩n que representa bien un juego suave:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Se dej칩 el factor en <code>float factor = 1.0 / dist;</code> (tiene m치s sentido) y los par치metros son los siguientes:</p>
<ul>
<li><code>gap</code>: 12.9</li>
<li><code>r</code>: 5</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Sin embargo, despu칠s de unas iteraciones el patr칩n se vuelve ca칩tico. Aunque, ese inicio es un logro.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>En este ejemplo se renderizan varios puntos aleatorios como estado inicial. Dale play (tanto como gustes 游뗵) para ver distintos patrones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="juego-de-la-vida-tuneado-colores">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>칔ltimo experimento. Darle un poco de vida con colores. Podr칤an modificarse las reglas para generar distintos estados dependiendo del color y es justo lo que se muestra a continuaci칩n:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Ahora los patrones son m치s estables y quedan varias c칠lulas autosuficientes. Los par치metros son:</p>
<ul>
<li><code>gap</code>: 13</li>
<li>Radio <code>r</code>: 5</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Se tienen 3 dimensiones por celda. Se calculan vecinos por cada dimension, por lo que <code>n</code> ahora es un <code>vec3</code>. La interacci칩n en este caso es pasar una dimensi칩n distinta para el c치lculo de la celda evaluada:</p>
<pre><code class="hljs language-glsl">live.r += -<span class="hljs-built_in">pow</span>(n.b - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.g += -<span class="hljs-built_in">pow</span>(n.r - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.b += -<span class="hljs-built_in">pow</span>(n.g - uGap, <span class="hljs-number">2.0</span>) + uGap;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Algo a notar es que hay patrones de expansi칩n rectos, esto es por el c치lculo de la vida en la vecindad. Se usan coordenadas polares, se da una vuelta y se va ampliando el radio. El problema est치 en la cantidad de puntos que se eval칰an por radio, como se muestra:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> <span class="hljs-keyword">points</span> = <span class="hljs-number">8.0</span> * r;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Aumentando la cantidad de puntos por radio requiere buscar otros par치metros, pero esto mejora en la estabilidad de los patrones:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><ul>
<li><code>gap</code>: 17.5</li>
<li><code>r</code>: 4</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Para estabilizar los colores se puede hacer m치s dependiente a cada dimensi칩n de las dem치s, un buen patron encontrado es el siguiente:</p>
<pre><code class="hljs language-glsl">live.r += -<span class="hljs-built_in">pow</span>((n.r) / <span class="hljs-number">2.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.g += -<span class="hljs-built_in">pow</span>((n.r + n.g) / <span class="hljs-number">3.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
live.b += -<span class="hljs-built_in">pow</span>((n.r + n.g + n.b) / <span class="hljs-number">4.0</span> - uGap, <span class="hljs-number">2.0</span>) + uGap;
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Ejec칰talo varias veces, se obtienen patrones bastante suaves pero hay momentos ca칩ticos.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Nota final:</p>
<p>Muchos de los c치lculos desde <em>tunear</em> son buscados al ojo. Son experimentos para pasar el rato (uno bueno). Si tienes alguna propuesta, feliz de escucharla o probarla!</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Recursos:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>No puedo terminar sin antes recrear el primer ejemplo con el nuevo aut칩mata creado!</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="autmatas-celulares-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">郊</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><p>Por esta ocasi칩n pondr칠 todo el c칩digo aqu칤 (siempre est치 disponible inspeccionando el iframe), puedes pegarlo y editarlo aqu칤:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="autmatas-celulares-en-glsl"><div class="font-sans w-full"><pre><code class="hljs language-js">p5.<span class="hljs-property">RendererGL</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_initContext</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span> =
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;webgl2&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pInst</span>.<span class="hljs-property">_glAttributes</span>) ||
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvas</span>.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;experimental-webgl&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_pInst</span>.<span class="hljs-property">_glAttributes</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error creating webgl context&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> gl = <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>;
      gl.<span class="hljs-title function_">enable</span>(gl.<span class="hljs-property">DEPTH_TEST</span>);
      gl.<span class="hljs-title function_">depthFunc</span>(gl.<span class="hljs-property">LEQUAL</span>);
      gl.<span class="hljs-title function_">viewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, gl.<span class="hljs-property">drawingBufferWidth</span>, gl.<span class="hljs-property">drawingBufferHeight</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_viewport</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>.<span class="hljs-title function_">getParameter</span>(
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">drawingContext</span>.<span class="hljs-property">VIEWPORT</span>
      );
    }
  } <span class="hljs-keyword">catch</span> (er) {
    <span class="hljs-keyword">throw</span> er;
  }
};

<span class="hljs-keyword">const</span> vertShader = <span class="hljs-string">`#version 300 es
in vec3 aPosition;
out vec2 vXY;
void main() {
  vec4 pos = vec4(aPosition, 1.0);
  vXY = pos.xy;
  pos = pos * 2.0 - 1.0;
  gl_Position = pos;
}`</span>;

<span class="hljs-keyword">const</span> fragShader = <span class="hljs-string">`#version 300 es
precision mediump float;
in vec2 vXY;
uniform float uWidth;
uniform float uHeight;
uniform float uR;
uniform float uLGap;
uniform float uGap;
uniform sampler2D uState;
uniform vec2 uCircle;
out vec4 fragColor;
const float PI = 3.14159264;

vec3 getState(float i, float j) {
  vec4 data = texture(
    uState,
    vec2(
      (i + 0.5) / uWidth,
      (j + 0.5) / uHeight
    )
  );
  return data.rgb;
}

void main() {
  float i = vXY.x * uWidth - 0.5;
  float j = uHeight - vXY.y * uHeight - 0.5;

  vec3 live = getState(i, j);

  vec3 n = vec3(0.0);
  for(float r = 1.0; r &lt;= uR; r++) {
    float points = 16.0 * r;
    for(float p = 0.0; p &lt; points; p++) {
      float k = i + r * cos(2.0 * PI * p / points);
      float l = j + r * sin(2.0 * PI * p / points);
      float dist = length(vec2(i, j) - vec2(k, l));
      float factor = 1.0 / dist;
      vec3 klLive = getState(k, l) * factor;
      n.r += klLive.r;
      n.g += klLive.g;
      n.b += klLive.b;
    }
  }

  vec2 pos = (vXY * 2.0 - 1.0);
  pos.x *= (uWidth / uHeight);
  float circleDist = length(pos - uCircle);
  
  if(circleDist &lt; 0.1) {
    live = vec3(1.0);
  } else {
    live.r += -pow((n.r) / 2.0 - uGap, 2.0) + uGap;
    live.g += -pow((n.r + n.g) / 3.0 - uGap, 2.0) + uGap;
    live.b += -pow((n.r + n.g + n.b) / 4.0 - uGap, 2.0) + uGap;
  }

  fragColor = vec4(live, 1.0);
}
`</span>;

<span class="hljs-keyword">let</span> myShader;
<span class="hljs-keyword">let</span> g;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">createCanvas</span>(<span class="hljs-number">350</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
  g = <span class="hljs-title function_">createGraphics</span>(<span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-variable constant_">WEBGL</span>);
  myShader = <span class="hljs-title function_">createShader</span>(vertShader, fragShader);

  g.<span class="hljs-title function_">shader</span>(myShader);
  g.<span class="hljs-title function_">stroke</span>(<span class="hljs-number">255</span>);
  g.<span class="hljs-title function_">fill</span>(<span class="hljs-number">255</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restart</span>(<span class="hljs-params"></span>) {
    g.<span class="hljs-title function_">background</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">const</span> points = <span class="hljs-number">3000</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= points; i++) {
      <span class="hljs-keyword">const</span> x = width * (<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">const</span> y = height * (<span class="hljs-title function_">random</span>(<span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);
      g.<span class="hljs-title function_">stroke</span>(<span class="hljs-title function_">color</span>(<span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>), <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>), <span class="hljs-title function_">random</span>(<span class="hljs-number">255</span>)));
      g.<span class="hljs-title function_">point</span>(x, y);
    }

    <span class="hljs-title function_">imageMode</span>(<span class="hljs-variable constant_">CENTER</span>);
    <span class="hljs-title function_">image</span>(g, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
  }

  <span class="hljs-title function_">restart</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> angle = frameCount / <span class="hljs-number">80</span>;
  <span class="hljs-keyword">const</span> uCircle = [<span class="hljs-title function_">cos</span>(angle) * <span class="hljs-number">0.6</span>, <span class="hljs-title function_">sin</span>(angle) * <span class="hljs-number">0.6</span>];
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uState&quot;</span>, g);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uCircle&quot;</span>, uCircle);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uR&quot;</span>, <span class="hljs-number">5</span>);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uGap&quot;</span>, <span class="hljs-number">13.7</span>);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uWidth&quot;</span>, width);
  myShader.<span class="hljs-title function_">setUniform</span>(<span class="hljs-string">&quot;uHeight&quot;</span>, height);
  g.<span class="hljs-title function_">rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-title function_">imageMode</span>(<span class="hljs-variable constant_">CENTER</span>);
  <span class="hljs-title function_">image</span>(g, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
}
</code></pre></div></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html>