<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Mandelbulb en GLSL"><meta name="twitter:title" content="Mandelbulb en GLSL"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #edu #art"><meta property="og:description" content="Tags: #tech #edu #art"><meta name="twitter:description" content="Tags: #tech #edu #art"><meta property="og:image" content="https://moloxe.github.io/blog/mandelbulb-en-glsl/img/mandelbulb.png"><meta name="twitter:image" content="https://moloxe.github.io/blog/mandelbulb-en-glsl/img/mandelbulb.png"><meta name="generator" content="Astro v5.16.9"><title>Mandelbulb en GLSL</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.CDGfc0hd.js"></script><link rel="stylesheet" href="/_astro/ants-test.DJx1_YBF.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.0BedYp8Q.js" component-export="default" renderer-url="/_astro/client.BZ2AD0De.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-sm font-mono px-4 pt-2 pb-8 text-neutral-400 leading-5 break-all max-sm:text-xs max-sm:pb-4 max-sm:px-2"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/mandelbulb-en-glsl" class="hover:text-white">mandelbulb-en-glsl</a>  </p>  <div class="font-extralight font-mono flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="1mjEjs" prefix="s0" component-url="/_astro/PostView.Cg2cuyrR.js" component-export="default" renderer-url="/_astro/client.BZ2AD0De.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Mandelbulb en GLSL&quot;],&quot;creationDate&quot;:[3,&quot;2024-06-07T16:45:43.427Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2024-08-01T20:04:38.244Z&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;edu&quot;],[0,&quot;art&quot;]]],&quot;container&quot;:[1,[[0,{&quot;text&quot;:[0,&quot;Esta es la continuaci√≥n espiritual de [shaders en corto](/blog/shaders-en-corto). Aqu√≠ describir√© los pasos para renderizar Mandelbulb en GLSL.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;/mandelbulb.png&quot;],&quot;type&quot;:[0,&quot;ImageBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Qu√© es Mandelbulb? un fractal en 3-dimensiones. De nada.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el post previo se muestra Mandelbrot (un fractal en 2-dimensiones) como se muestra a continuaci√≥n:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float zoom;\\nfloat scale = 2.0;\\nconst int maxIt = 300;\\n\\nvoid main() {\\n  vec2 Z = vec2(0);\\n  vec2 C = vec2(vXY * scale * zoom);\\n  C.x -= 1.7864385;\\n  int it = 0;\\n  for(int i = 0; i &lt; maxIt; ++i) {\\n    if(length(Z) &gt; 16.0) {\\n      break;\\n    }\\n    Z = vec2(\\n      Z.x*Z.x - Z.y*Z.y + C.x,\\n      2.0 * Z.x * Z.y + C.y\\n    );\\n    it++;\\n  }\\n  if(maxIt == it) it = 0;\\n  float c = float(it)/float(maxIt);\\n  c = sqrt(c);\\n  float g = c;\\n  float b = sqrt(c);\\n  float r = c * (1.0 - c);\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  mat = [];\\n  createCanvas(350, 320, WEBGL);\\n}\\n\\nlet zoom = 1;\\nlet dir = 0.99;\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;zoom\\\&quot;, zoom);\\n  rect(0, 0, 0, 0);\\n  zoom *= dir;\\n  if (zoom &lt; 2e-6) dir = 1 + (1 - dir);\\n  if (zoom &gt; 2) dir = 2 - dir;\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Mandelbulb tiene la intenci√≥n de mostrar como ser√≠a Mandelbrot en 3-dimensiones. Y si me equivoco, pues me equivoqu√©.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Trayectoria:\n- Contexto: El objetivo es renderizar Mandelbulb en GLSL, por diversi√≥n üëç\n- Limitaciones: Conocimientos de `ray marching` prematuros y de √°lgebra lineal no muy remotos. (lado positivo: algunas cosas son caja negra)\n- Retroalimentaci√≥n: No hay üëç&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;La intenci√≥n es construir una versi√≥n propia, separada por partes (a mi manera (es una dictadura)).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Ray marching en GLSL&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El `ray marching` es la t√©cnica que se usar√° para renderizar Mandelbulb. Existen otras, es probable que tambi√©n sirvan, pero parto de la asunci√≥n de que es posible ya que existen muchas implementaciones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Esta t√©cnica es iterativa, busca la intersecci√≥n entre un supuesto rayo de luz y un objeto. En otras palabras, se lanza un rayo de luz desde un punto de la pantalla hasta encontrar un objeto.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para aplicar la t√©cnica en GLSL la parte importante es el `fragment shader`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\n\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nfloat sdCube(vec3 p) {\\n  vec3 boxSize = vec3(1.0, 1.0, 1.0);\\n  vec3 d = abs(p) - boxSize;\\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\\n}\\n\\nfloat distanceField(vec3 p) {\\n  float angle = uTime;\\n  p = rotationY(angle) * p;\\n  p = rotationX(angle) * p;\\n  return sdCube(p);\\n}\\n\\nvec3 rayMarch(vec3 ro, vec3 rd) {\\n\\n  // Menor valor oculta la escena de de atr√°s hacia adelante\\n  const float maxDistance = 100.0;\\n\\n  // Menor valor oculta las esquinas de los objetos\\n  const float minDistance = 0.001;\\n\\n  // Mayor valor aumenta la fidelidad de la im√°gen a mayor coste computacional\\n  const int maxIter = 100;\\n\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    float d = distanceField(p);\\n    if (d &lt; minDistance) {\\n      return vec3(p); // Superficie\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n\\n  return vec3(0.0, 0.0, 0.0); // Fondo\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 4.0); // Posici√≥n del observador\\n  vec3 rd = normalize(vec3(uv, -1.0)); // Direcci√≥n del rayo\\n\\n  vec3 color = rayMarch(ro, rd);\\n\\n  gl_FragColor = vec4(color, 1.0);\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El fragment shader es el siguiente:\n\n```glsl\nprecision highp float;\nvarying vec2 uv;\nuniform float uTime;\n\nmat3 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, -s,\n    0.0, s, c\n  );\n}\n\nmat3 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c\n  );\n}\n\nfloat sdCube(vec3 p) {\n  vec3 boxSize = vec3(1.0, 1.0, 1.0);\n  vec3 d = abs(p) - boxSize;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat distanceField(vec3 p) {\n  float angle = uTime;\n  p = rotationY(angle) * p;\n  p = rotationX(angle) * p;\n  return sdCube(p);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\n  // Menor valor oculta la escena de de atr√°s hacia adelante\n  const float maxDistance = 100.0;\n\n  // Menor valor oculta las esquinas de los objetos\n  const float minDistance = 0.001;\n\n  // Mayor valor aumenta la fidelidad de la im√°gen a mayor coste computacional\n  const int maxIter = 100;\n\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; maxIter; i++) {\n    p = ro + totalDistance * rd;\n    float d = distanceField(p);\n    if (d &lt; minDistance) {\n      return vec3(p); // Superficie\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n\n  return vec3(0.0, 0.0, 0.0); // Fondo\n}\n\nvoid main() {\n  vec3 ro = vec3(0.0, 0.0, 4.0); // Posici√≥n del observador\n  vec3 rd = normalize(vec3(uv, -1.0)); // Direcci√≥n del rayo\n\n  vec3 color = rayMarch(ro, rd);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Olvida todo!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Son muchas cosas pero lo importante es `rayMarch`:\n\n```glsl\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\n  // Menor valor oculta la escena de de atr√°s hacia adelante\n  const float maxDistance = 100.0;\n\n  // Menor valor oculta las esquinas de los objetos\n  const float minDistance = 0.001;\n\n  // Mayor valor aumenta la fidelidad de la im√°gen a mayor coste computacional\n  const int maxIter = 100;\n\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; 100; i++) {\n    p = ro + totalDistance * rd;\n    float d = distanceField(p);\n    if (d &lt; minDistance) {\n      return vec3(p); // Superficie\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n\n  return vec3(0.0, 0.0, 0.0); // Fondo\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;A diferencia de otros m√©todos de renderizado, este es estimado. La parte m√°s *relevante* es la que nos permite obtener la coordenada `p`. Se obtiene de forma iterativa, cuando la distancia cumple con la condici√≥n de ser menor a `minDistance` el punto `p` es considerado parte de la escena (de alguna superficie). Con ello se puede asignar un valor al color.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El resto del c√≥digo son utilidades (√°lgebra lineal: posiciones, rayos de luz, rotaciones, etc...). Para los objetos existen muchas funciones con las que se puede calcular la distancia a uno de ellos, puedes revisar:\n- https://iquilezles.org/articles/distfunctions/ ‚ú®&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En `distanceField` es donde se calculan las distancias a cada objeto, en este caso hace rotaciones y calcula la distancia a un cubo.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Mandelbulb&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;La referencia principal se toma del siguiente recurso:\n- https://editor.p5js.org/Taxen99/sketches/47CDg5-nV by Taxen99&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Tambi√©n sirve ver la referencia en wikipedia:\n- https://wikipedia.org/wiki/Mandelbulb&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(angle) * p;\\n  p = rotationX(PI / 2.0) * p;\\n  return sdMandelbulb(p, 8.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float g = effort;\\n      float b = 1.0 - effort;\\n      return vec4(0.0, g, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 1.6);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pasos:\n1. Evaluar el punto en un √°rea de 3-dimensiones.\n2. Calcular si pertenece al conjunto dado un *criterio*.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Suena simple pero el criterio es extenso. Primero es necesario pasar la coordenada `p` a coordenadas esf√©ricas:\n\n```glsl\nvec3 toSpherical(vec3 p) {\n  float r = length(p);\n  float theta = acos(p.z / r);\n  float phi = atan(p.y, p.x);\n  return vec3(r, theta, phi);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No puedo decir mucho, la f√≥rmula de White y Nylander hacen posible el c√°lculo del conjunto de Mandelbulb. ‚ú®&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para no entrar en mucho detalle, empecemos del `main`:\n```glsl\nvoid main() {\n  vec3 ro = vec3(0.0, 0.0, 1.6);\n  vec3 rd = normalize(vec3(uv, -1.0));\n  vec4 color = rayMarch(ro, rd);\n  gl_FragColor = color;\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Es lo mismo que en ejemplos anteriores, se modificaron los valores para mostrar una visualizaci√≥n m√°s apreciable.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`rayMarch`:\n```glsl\nvec4 rayMarch(vec3 ro, vec3 rd) {\n  const float maxDistance = 100.0;\n  const float minDistance = 0.001;\n  const int maxIter = 100;\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; maxIter; i++) {\n    p = ro + totalDistance * rd;\n    vec2 dfVec = distanceField(p);\n    float d = dfVec.x;\n    if (d &lt; minDistance) {\n      float effort = dfVec.y;\n      float g = effort;\n      float b = 1.0 - effort;\n      return vec4(0.0, g, b, 1.0);\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n  return vec4(0.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se a√±adi√≥ un par√°metro extra (`effort`) que representa cuantas iteraciones se realizaron para saber si una coordenada pertenece al conjunto (verde: muchas iteraciones, azul: pocas iteraciones).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`distanceField`:\n```glsl\nvec2 distanceField(vec3 p) {\n  float angle = uTime / 10.0;\n  p = rotationY(angle) * p;\n  p = rotationX(PI / 2.0) * p;\n  return sdMandelbulb(p, 8.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para apreciar el mejor el fractal, se hacen ligeras rotaciones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`sdMandelbulb`: üíÄ\n```glsl\nvec2 sdMandelbulb(vec3 p, float power) {\n  const int maxIter = 12;\n\n  vec3 zeta = p;\n  float dr = 1.0;\n  float r = 0.0;\n  int iterations = 0;\n  for (int _ = 0; _ &lt; maxIter; _++) {\n    iterations++;\n\n    vec3 spherical = toSpherical(zeta);\n    r = spherical.x;\n    if (r &gt; 2.0) {\n      break;\n    }\n\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n    float theta = spherical.y * power;\n    float phi = spherical.z * power;\n    float sinTheta = sin(theta);\n\n    float powx = pow(r, power) * sinTheta * cos(phi);\n    float powy = pow(r, power) * sinTheta * sin(phi);\n    float powz = pow(r, power) * cos(theta);\n\n    zeta.x = powx + p.x;\n    zeta.y = powy + p.y;\n    zeta.z = powz + p.z;\n  }\n  float d = 0.5 * log(r) * r / dr;\n  float effort = float(iterations) / float(maxIter);\n  return vec2(d, effort);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Esta funci√≥n estima la distancia a una coordenada que pertenezca al conjunto de Mandelbulb. No comprendo muy bien el c√°lculo de `dr`, pero entiendo que es su prop√≥sito.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Adicionalmente, se a√±adi√≥ `effort` como una utilidad para distinguir entre los puntos del conjunto.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el ejemplo anterior se usa una potencia de 8, sin embargo, lo genial viene de probar distintos valores.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Update (2024-08-01)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Una referencia (para entrar a fondo) la pueden encontrar en el comentario `mandelbulbSDF.glsl` de `lygia`:\n\nhttps://github.com/patriciogonzalezvivo/lygia/blob/main/sdf/mandelbulbSDF.glsl#L40\n\n```glsl\n// distance estimation through the Hubbard-Douady potential from Inigo Quilez\nreturn vec2(0.25*log(m) * sqrt(m) / dz, iterations);\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No entiendo con certeza la similitud con lo que consegu√≠, pero obivo existe...&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Experimentos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## n = min(time, 8)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(angle) * p;\\n  // p = rotationX(PI / 2.0) * p;\\n  return sdMandelbulb(p, min(uTime, 8.0));\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float r = effort;\\n      float b = 1.0 - effort;\\n      return vec4(r, r/b, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 2.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Este es muy similar al del post anterior.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## n = 8, rotateXY(time)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 2.0;\\n  p = rotationY(angle) * p;\\n  p = rotationX(angle) * p;\\n  return sdMandelbulb(p, 8.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float r = effort;\\n      float b = 1.0 - effort;\\n      return vec4(r, r/b, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 2.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Portada&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 10;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(PI * 3.0 / 2.0) * p;\\n  p = rotationX(PI * 5.0 / 4.0) * p;\\n  return sdMandelbulb(p, 6.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.0001;\\n  const int maxIter = 300;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float b = sqrt(1.0 - effort);\\n      float a = 1.0 - b;\\n      return vec4(a, 0.6 * b/a, a*b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(-0.6, 0.6, 1.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n  // save(&#39;mandelbulb.jpg&#39;)\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Eso, el c√≥digo con el que se cre√≥ la portada est√° en ese `iframe`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Recursos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- [Shaders en corto](/blog/shaders-en-corto)\n- https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n- https://wikipedia.org/wiki/Mandelbulb\n- https://editor.p5js.org/Taxen99/sketches/47CDg5-nV&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota: A nivel personal me queda pendiente experimentar con estados previos para calcular el siguiente, as√≠ como en el juego de la vida del post anterior. Igual lo dejo again (copiar es gratis):&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist &lt; 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i &lt; uStateSize; i++) {\\n    for (let j = 0; j &lt; uStateSize; j++) {\\n      if (random(1) &gt; 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}]]],&quot;isPinned&quot;:[0,true],&quot;slugUrl&quot;:[0,&quot;mandelbulb-en-glsl&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Junio 7, 2024</div><p class="text-neutral-400 text-xs flex gap-1">5 minutos de lectura </p></div><h1>Mandelbulb en GLSL</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">√çndice:</h2><div><!----><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#ray-marching-en-glsl" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Ray marching en GLSL"><p>Ray marching en GLSL</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#olvida-todo" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Olvida todo!"><p>Olvida todo!</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#mandelbulb" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Mandelbulb"><p>Mandelbulb</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#update-2024-08-01" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Update (2024-08-01)"><p>Update (2024-08-01)</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#experimentos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Experimentos"><p>Experimentos</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#n-mintime-8" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="n = min(time, 8)"><p>n = min(time, 8)</p>
</a><!----></li><li><a href="/blog/mandelbulb-en-glsl/#n-8-rotatexytime" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="n = 8, rotateXY(time)"><p>n = 8, rotateXY(time)</p>
</a><!----></li><li><a href="/blog/mandelbulb-en-glsl/#portada" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Portada"><p>Portada</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#recursos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Recursos"><p>Recursos</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta es la continuaci√≥n espiritual de <a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a>. Aqu√≠ describir√© los pasos para renderizar Mandelbulb en GLSL.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex flex-col w-full"><img loading="lazy" class="w-auto h-80 object-contain bg-black bg-opacity-30" src="/blog/mandelbulb-en-glsl/img/mandelbulb.png"><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Qu√© es Mandelbulb? un fractal en 3-dimensiones. De nada.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En el post previo se muestra Mandelbrot (un fractal en 2-dimensiones) como se muestra a continuaci√≥n:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Mandelbulb tiene la intenci√≥n de mostrar como ser√≠a Mandelbrot en 3-dimensiones. Y si me equivoco, pues me equivoqu√©.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Trayectoria:</p>
<ul>
<li>Contexto: El objetivo es renderizar Mandelbulb en GLSL, por diversi√≥n üëç</li>
<li>Limitaciones: Conocimientos de <code>ray marching</code> prematuros y de √°lgebra lineal no muy remotos. (lado positivo: algunas cosas son caja negra)</li>
<li>Retroalimentaci√≥n: No hay üëç</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>La intenci√≥n es construir una versi√≥n propia, separada por partes (a mi manera (es una dictadura)).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="ray-marching-en-glsl">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El <code>ray marching</code> es la t√©cnica que se usar√° para renderizar Mandelbulb. Existen otras, es probable que tambi√©n sirvan, pero parto de la asunci√≥n de que es posible ya que existen muchas implementaciones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta t√©cnica es iterativa, busca la intersecci√≥n entre un supuesto rayo de luz y un objeto. En otras palabras, se lanza un rayo de luz desde un punto de la pantalla hasta encontrar un objeto.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para aplicar la t√©cnica en GLSL la parte importante es el <code>fragment shader</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El fragment shader es el siguiente:</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">precision</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">float</span>;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> uv;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uTime;

<span class="hljs-type">mat3</span> rotationX(<span class="hljs-type">float</span> angle) {
  <span class="hljs-type">float</span> c = <span class="hljs-built_in">cos</span>(angle);
  <span class="hljs-type">float</span> s = <span class="hljs-built_in">sin</span>(angle);
  <span class="hljs-keyword">return</span> <span class="hljs-type">mat3</span>(
    <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,
    <span class="hljs-number">0.0</span>, c, -s,
    <span class="hljs-number">0.0</span>, s, c
  );
}

<span class="hljs-type">mat3</span> rotationY(<span class="hljs-type">float</span> angle) {
  <span class="hljs-type">float</span> c = <span class="hljs-built_in">cos</span>(angle);
  <span class="hljs-type">float</span> s = <span class="hljs-built_in">sin</span>(angle);
  <span class="hljs-keyword">return</span> <span class="hljs-type">mat3</span>(
    c, <span class="hljs-number">0.0</span>, s,
    <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,
    -s, <span class="hljs-number">0.0</span>, c
  );
}

<span class="hljs-type">float</span> sdCube(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">vec3</span> boxSize = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);
  <span class="hljs-type">vec3</span> d = <span class="hljs-built_in">abs</span>(p) - boxSize;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">length</span>(<span class="hljs-built_in">max</span>(d, <span class="hljs-number">0.0</span>)) + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(d.x, <span class="hljs-built_in">max</span>(d.y, d.z)), <span class="hljs-number">0.0</span>);
}

<span class="hljs-type">float</span> distanceField(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> angle = uTime;
  p = rotationY(angle) * p;
  p = rotationX(angle) * p;
  <span class="hljs-keyword">return</span> sdCube(p);
}

<span class="hljs-type">vec3</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {

  <span class="hljs-comment">// Menor valor oculta la escena de de atr√°s hacia adelante</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;

  <span class="hljs-comment">// Menor valor oculta las esquinas de los objetos</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;

  <span class="hljs-comment">// Mayor valor aumenta la fidelidad de la im√°gen a mayor coste computacional</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;

  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxIter; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">float</span> d = distanceField(p);
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(p); <span class="hljs-comment">// Superficie</span>
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Fondo</span>
}

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec3</span> ro = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">4.0</span>); <span class="hljs-comment">// Posici√≥n del observador</span>
  <span class="hljs-type">vec3</span> rd = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(uv, <span class="hljs-number">-1.0</span>)); <span class="hljs-comment">// Direcci√≥n del rayo</span>

  <span class="hljs-type">vec3</span> color = rayMarch(ro, rd);

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color, <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="olvida-todo">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Son muchas cosas pero lo importante es <code>rayMarch</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec3</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {

  <span class="hljs-comment">// Menor valor oculta la escena de de atr√°s hacia adelante</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;

  <span class="hljs-comment">// Menor valor oculta las esquinas de los objetos</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;

  <span class="hljs-comment">// Mayor valor aumenta la fidelidad de la im√°gen a mayor coste computacional</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;

  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">float</span> d = distanceField(p);
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(p); <span class="hljs-comment">// Superficie</span>
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Fondo</span>
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>A diferencia de otros m√©todos de renderizado, este es estimado. La parte m√°s <em>relevante</em> es la que nos permite obtener la coordenada <code>p</code>. Se obtiene de forma iterativa, cuando la distancia cumple con la condici√≥n de ser menor a <code>minDistance</code> el punto <code>p</code> es considerado parte de la escena (de alguna superficie). Con ello se puede asignar un valor al color.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El resto del c√≥digo son utilidades (√°lgebra lineal: posiciones, rayos de luz, rotaciones, etc...). Para los objetos existen muchas funciones con las que se puede calcular la distancia a uno de ellos, puedes revisar:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a> ‚ú®</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En <code>distanceField</code> es donde se calculan las distancias a cada objeto, en este caso hace rotaciones y calcula la distancia a un cubo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="mandelbulb">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>La referencia principal se toma del siguiente recurso:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a> by Taxen99</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Tambi√©n sirve ver la referencia en wikipedia:</p>
<ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Pasos:</p>
<ol>
<li>Evaluar el punto en un √°rea de 3-dimensiones.</li>
<li>Calcular si pertenece al conjunto dado un <em>criterio</em>.</li>
</ol>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Suena simple pero el criterio es extenso. Primero es necesario pasar la coordenada <code>p</code> a coordenadas esf√©ricas:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec3</span> toSpherical(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> r = <span class="hljs-built_in">length</span>(p);
  <span class="hljs-type">float</span> theta = <span class="hljs-built_in">acos</span>(p.z / r);
  <span class="hljs-type">float</span> phi = <span class="hljs-built_in">atan</span>(p.y, p.x);
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(r, theta, phi);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>No puedo decir mucho, la f√≥rmula de White y Nylander hacen posible el c√°lculo del conjunto de Mandelbulb. ‚ú®</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para no entrar en mucho detalle, empecemos del <code>main</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec3</span> ro = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.6</span>);
  <span class="hljs-type">vec3</span> rd = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(uv, <span class="hljs-number">-1.0</span>));
  <span class="hljs-type">vec4</span> color = rayMarch(ro, rd);
  <span class="hljs-built_in">gl_FragColor</span> = color;
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Es lo mismo que en ejemplos anteriores, se modificaron los valores para mostrar una visualizaci√≥n m√°s apreciable.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>rayMarch</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec4</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;
  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxIter; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">vec2</span> dfVec = distanceField(p);
    <span class="hljs-type">float</span> d = dfVec.x;
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-type">float</span> effort = dfVec.y;
      <span class="hljs-type">float</span> g = effort;
      <span class="hljs-type">float</span> b = <span class="hljs-number">1.0</span> - effort;
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, g, b, <span class="hljs-number">1.0</span>);
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Se a√±adi√≥ un par√°metro extra (<code>effort</code>) que representa cuantas iteraciones se realizaron para saber si una coordenada pertenece al conjunto (verde: muchas iteraciones, azul: pocas iteraciones).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>distanceField</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec2</span> distanceField(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> angle = uTime / <span class="hljs-number">10.0</span>;
  p = rotationY(angle) * p;
  p = rotationX(PI / <span class="hljs-number">2.0</span>) * p;
  <span class="hljs-keyword">return</span> sdMandelbulb(p, <span class="hljs-number">8.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para apreciar el mejor el fractal, se hacen ligeras rotaciones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>sdMandelbulb</code>: üíÄ</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec2</span> sdMandelbulb(<span class="hljs-type">vec3</span> p, <span class="hljs-type">float</span> power) {
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">12</span>;

  <span class="hljs-type">vec3</span> zeta = p;
  <span class="hljs-type">float</span> dr = <span class="hljs-number">1.0</span>;
  <span class="hljs-type">float</span> r = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">int</span> iterations = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> _ = <span class="hljs-number">0</span>; _ &lt; maxIter; _++) {
    iterations++;

    <span class="hljs-type">vec3</span> spherical = toSpherical(zeta);
    r = spherical.x;
    <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">2.0</span>) {
      <span class="hljs-keyword">break</span>;
    }

    dr = <span class="hljs-built_in">pow</span>(r, power - <span class="hljs-number">1.0</span>) * power * dr + <span class="hljs-number">1.0</span>;

    <span class="hljs-type">float</span> theta = spherical.y * power;
    <span class="hljs-type">float</span> phi = spherical.z * power;
    <span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sin</span>(theta);

    <span class="hljs-type">float</span> powx = <span class="hljs-built_in">pow</span>(r, power) * sinTheta * <span class="hljs-built_in">cos</span>(phi);
    <span class="hljs-type">float</span> powy = <span class="hljs-built_in">pow</span>(r, power) * sinTheta * <span class="hljs-built_in">sin</span>(phi);
    <span class="hljs-type">float</span> powz = <span class="hljs-built_in">pow</span>(r, power) * <span class="hljs-built_in">cos</span>(theta);

    zeta.x = powx + p.x;
    zeta.y = powy + p.y;
    zeta.z = powz + p.z;
  }
  <span class="hljs-type">float</span> d = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">log</span>(r) * r / dr;
  <span class="hljs-type">float</span> effort = <span class="hljs-type">float</span>(iterations) / <span class="hljs-type">float</span>(maxIter);
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec2</span>(d, effort);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta funci√≥n estima la distancia a una coordenada que pertenezca al conjunto de Mandelbulb. No comprendo muy bien el c√°lculo de <code>dr</code>, pero entiendo que es su prop√≥sito.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Adicionalmente, se a√±adi√≥ <code>effort</code> como una utilidad para distinguir entre los puntos del conjunto.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En el ejemplo anterior se usa una potencia de 8, sin embargo, lo genial viene de probar distintos valores.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="update-2024-08-01">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Una referencia (para entrar a fondo) la pueden encontrar en el comentario <code>mandelbulbSDF.glsl</code> de <code>lygia</code>:</p>
<p><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// distance estimation through the Hubbard-Douady potential from Inigo Quilez</span>
<span class="hljs-keyword">return</span> <span class="hljs-type">vec2</span>(<span class="hljs-number">0.25</span>*<span class="hljs-built_in">log</span>(m) * <span class="hljs-built_in">sqrt</span>(m) / dz, iterations);
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>No entiendo con certeza la similitud con lo que consegu√≠, pero obivo existe...</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="experimentos">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="n-mintime-8">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Este es muy similar al del post anterior.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="n-8-rotatexytime">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="portada">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Eso, el c√≥digo con el que se cre√≥ la portada est√° en ese <code>iframe</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hundefined class="font-mono" id="recursos">[object Object]</hundefined></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><ul>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
<li><a href="[object Object]" title="undefined" class="text-primary [word-break:break-word]" target="_blank">undefined</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Nota: A nivel personal me queda pendiente experimentar con estados previos para calcular el siguiente, as√≠ como en el juego de la vida del post anterior. Igual lo dejo again (copiar es gratis):</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">‚ñ∫</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html>