<!DOCTYPE html><html lang="es"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta property="og:title" content="Mandelbulb en GLSL"><meta name="twitter:title" content="Mandelbulb en GLSL"><!-- <meta property="og:url" content={canonicalHref} /> --><meta name="description" content="Tags: #tech #edu #art"><meta property="og:description" content="Tags: #tech #edu #art"><meta name="twitter:description" content="Tags: #tech #edu #art"><meta property="og:image" content="https://moloxe.github.io/blog/mandelbulb-en-glsl/img/mandelbulb.png"><meta name="twitter:image" content="https://moloxe.github.io/blog/mandelbulb-en-glsl/img/mandelbulb.png"><meta name="generator" content="Astro v5.13.7"><title>Mandelbulb en GLSL</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><!-- <link rel="canonical" href={canonicalHref} /> --><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.U4jOVs4w.js"></script><link rel="stylesheet" href="/_astro/index.jVteX0gD.css">
<style>:root{font-weight:200;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.edit-block{overflow:hidden;border-radius:.25rem;--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
</style>
<link rel="stylesheet" href="/_astro/index.C_nTHtqA.css">
<style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-built_in,.hljs-class .hljs-title,.hljs-title.class_{color:#e6c07b}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}
</style></head> <body> <img class="absolute w-0 h-0" src="https://librecounter.org/counter.svg" loading="eager" decoding="async" referrerpolicy="unsafe-url" id="libre-counter"> <div class="absolute w-0 h-0" data-astro-transition-persist="astro-bfx3ztbg-1"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1EHrjx" prefix="s1" component-url="/_astro/index.Dsb0rzSj.js" component-export="default" renderer-url="/_astro/client.YuukYgdX.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;OnekoStack&quot;,&quot;value&quot;:true}" await-children><!--[--><!--]--><!--astro:end--></astro-island> </div> <p class="text-xs font-mono p-2 text-neutral-400 leading-5 break-all"> <a href="/" class="hover:text-white">Home</a>  / <a href="/blog" class="hover:text-white">blog</a>  / <a href="/blog/mandelbulb-en-glsl" class="hover:text-white">mandelbulb-en-glsl</a>  </p>  <div class="flex flex-col w-full h-full print:max-w-full mx-auto max-w-3xl">  <astro-island uid="Z2jq1SJ" prefix="s0" component-url="/_astro/PostView.D3tUf3vJ.js" component-export="default" renderer-url="/_astro/client.YuukYgdX.js" props="{&quot;post&quot;:[0,{&quot;title&quot;:[0,&quot;Mandelbulb en GLSL&quot;],&quot;creationDate&quot;:[3,&quot;2024-06-07T16:45:43.427Z&quot;],&quot;lastUpdate&quot;:[3,&quot;2024-08-01T20:04:38.244Z&quot;],&quot;categories&quot;:[1,[[0,&quot;tech&quot;],[0,&quot;edu&quot;],[0,&quot;art&quot;]]],&quot;container&quot;:[1,[[0,{&quot;text&quot;:[0,&quot;Esta es la continuación espiritual de [shaders en corto](/blog/shaders-en-corto). Aquí describiré los pasos para renderizar Mandelbulb en GLSL.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;/mandelbulb.png&quot;],&quot;type&quot;:[0,&quot;ImageBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Qué es Mandelbulb? un fractal en 3-dimensiones. De nada.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el post previo se muestra Mandelbrot (un fractal en 2-dimensiones) como se muestra a continuación:&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  vXY = pos.xy;\\n  gl_Position = pos;\\n}\\n\\n`;\\n\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform float zoom;\\nfloat scale = 2.0;\\nconst int maxIt = 300;\\n\\nvoid main() {\\n  vec2 Z = vec2(0);\\n  vec2 C = vec2(vXY * scale * zoom);\\n  C.x -= 1.7864385;\\n  int it = 0;\\n  for(int i = 0; i &lt; maxIt; ++i) {\\n    if(length(Z) &gt; 16.0) {\\n      break;\\n    }\\n    Z = vec2(\\n      Z.x*Z.x - Z.y*Z.y + C.x,\\n      2.0 * Z.x * Z.y + C.y\\n    );\\n    it++;\\n  }\\n  if(maxIt == it) it = 0;\\n  float c = float(it)/float(maxIt);\\n  c = sqrt(c);\\n  float g = c;\\n  float b = sqrt(c);\\n  float r = c * (1.0 - c);\\n  gl_FragColor = vec4(r, g, b, 1.0);\\n}\\n`;\\n\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  mat = [];\\n  createCanvas(350, 320, WEBGL);\\n}\\n\\nlet zoom = 1;\\nlet dir = 0.99;\\nfunction draw() {\\n  background(0);\\n  shader(myShader);\\n  myShader.setUniform(\\\&quot;zoom\\\&quot;, zoom);\\n  rect(0, 0, 0, 0);\\n  zoom *= dir;\\n  if (zoom &lt; 2e-6) dir = 1 + (1 - dir);\\n  if (zoom &gt; 2) dir = 2 - dir;\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Mandelbulb tiene la intención de mostrar como sería Mandelbrot en 3-dimensiones. Y si me equivoco, pues me equivoqué.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Trayectoria:\n- Contexto: El objetivo es renderizar Mandelbulb en GLSL, por diversión 👍\n- Limitaciones: Conocimientos de `ray marching` prematuros y de álgebra lineal no muy remotos. (lado positivo: algunas cosas son caja negra)\n- Retroalimentación: No hay 👍&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;La intención es construir una versión propia, separada por partes (a mi manera (es una dictadura)).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Ray marching en GLSL&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El `ray marching` es la técnica que se usará para renderizar Mandelbulb. Existen otras, es probable que también sirvan, pero parto de la asunción de que es posible ya que existen muchas implementaciones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Esta técnica es iterativa, busca la intersección entre un supuesto rayo de luz y un objeto. En otras palabras, se lanza un rayo de luz desde un punto de la pantalla hasta encontrar un objeto.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para aplicar la técnica en GLSL la parte importante es el `fragment shader`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\n\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nfloat sdCube(vec3 p) {\\n  vec3 boxSize = vec3(1.0, 1.0, 1.0);\\n  vec3 d = abs(p) - boxSize;\\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\\n}\\n\\nfloat distanceField(vec3 p) {\\n  float angle = uTime;\\n  p = rotationY(angle) * p;\\n  p = rotationX(angle) * p;\\n  return sdCube(p);\\n}\\n\\nvec3 rayMarch(vec3 ro, vec3 rd) {\\n\\n  // Menor valor oculta la escena de de atrás hacia adelante\\n  const float maxDistance = 100.0;\\n\\n  // Menor valor oculta las esquinas de los objetos\\n  const float minDistance = 0.001;\\n\\n  // Mayor valor aumenta la fidelidad de la imágen a mayor coste computacional\\n  const int maxIter = 100;\\n\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    float d = distanceField(p);\\n    if (d &lt; minDistance) {\\n      return vec3(p); // Superficie\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n\\n  return vec3(0.0, 0.0, 0.0); // Fondo\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 4.0); // Posición del observador\\n  vec3 rd = normalize(vec3(uv, -1.0)); // Dirección del rayo\\n\\n  vec3 color = rayMarch(ro, rd);\\n\\n  gl_FragColor = vec4(color, 1.0);\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El fragment shader es el siguiente:\n\n```glsl\nprecision highp float;\nvarying vec2 uv;\nuniform float uTime;\n\nmat3 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, -s,\n    0.0, s, c\n  );\n}\n\nmat3 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c\n  );\n}\n\nfloat sdCube(vec3 p) {\n  vec3 boxSize = vec3(1.0, 1.0, 1.0);\n  vec3 d = abs(p) - boxSize;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat distanceField(vec3 p) {\n  float angle = uTime;\n  p = rotationY(angle) * p;\n  p = rotationX(angle) * p;\n  return sdCube(p);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\n  // Menor valor oculta la escena de de atrás hacia adelante\n  const float maxDistance = 100.0;\n\n  // Menor valor oculta las esquinas de los objetos\n  const float minDistance = 0.001;\n\n  // Mayor valor aumenta la fidelidad de la imágen a mayor coste computacional\n  const int maxIter = 100;\n\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; maxIter; i++) {\n    p = ro + totalDistance * rd;\n    float d = distanceField(p);\n    if (d &lt; minDistance) {\n      return vec3(p); // Superficie\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n\n  return vec3(0.0, 0.0, 0.0); // Fondo\n}\n\nvoid main() {\n  vec3 ro = vec3(0.0, 0.0, 4.0); // Posición del observador\n  vec3 rd = normalize(vec3(uv, -1.0)); // Dirección del rayo\n\n  vec3 color = rayMarch(ro, rd);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Olvida todo!&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Son muchas cosas pero lo importante es `rayMarch`:\n\n```glsl\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\n  // Menor valor oculta la escena de de atrás hacia adelante\n  const float maxDistance = 100.0;\n\n  // Menor valor oculta las esquinas de los objetos\n  const float minDistance = 0.001;\n\n  // Mayor valor aumenta la fidelidad de la imágen a mayor coste computacional\n  const int maxIter = 100;\n\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; 100; i++) {\n    p = ro + totalDistance * rd;\n    float d = distanceField(p);\n    if (d &lt; minDistance) {\n      return vec3(p); // Superficie\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n\n  return vec3(0.0, 0.0, 0.0); // Fondo\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;A diferencia de otros métodos de renderizado, este es estimado. La parte más *relevante* es la que nos permite obtener la coordenada `p`. Se obtiene de forma iterativa, cuando la distancia cumple con la condición de ser menor a `minDistance` el punto `p` es considerado parte de la escena (de alguna superficie). Con ello se puede asignar un valor al color.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;El resto del código son utilidades (álgebra lineal: posiciones, rayos de luz, rotaciones, etc...). Para los objetos existen muchas funciones con las que se puede calcular la distancia a uno de ellos, puedes revisar:\n- https://iquilezles.org/articles/distfunctions/ ✨&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En `distanceField` es donde se calculan las distancias a cada objeto, en este caso hace rotaciones y calcula la distancia a un cubo.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Mandelbulb&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;La referencia principal se toma del siguiente recurso:\n- https://editor.p5js.org/Taxen99/sketches/47CDg5-nV by Taxen99&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;También sirve ver la referencia en wikipedia:\n- https://wikipedia.org/wiki/Mandelbulb&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(angle) * p;\\n  p = rotationX(PI / 2.0) * p;\\n  return sdMandelbulb(p, 8.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float g = effort;\\n      float b = 1.0 - effort;\\n      return vec4(0.0, g, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 1.6);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Pasos:\n1. Evaluar el punto en un área de 3-dimensiones.\n2. Calcular si pertenece al conjunto dado un *criterio*.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Suena simple pero el criterio es extenso. Primero es necesario pasar la coordenada `p` a coordenadas esféricas:\n\n```glsl\nvec3 toSpherical(vec3 p) {\n  float r = length(p);\n  float theta = acos(p.z / r);\n  float phi = atan(p.y, p.x);\n  return vec3(r, theta, phi);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No puedo decir mucho, la fórmula de White y Nylander hacen posible el cálculo del conjunto de Mandelbulb. ✨&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para no entrar en mucho detalle, empecemos del `main`:\n```glsl\nvoid main() {\n  vec3 ro = vec3(0.0, 0.0, 1.6);\n  vec3 rd = normalize(vec3(uv, -1.0));\n  vec4 color = rayMarch(ro, rd);\n  gl_FragColor = color;\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Es lo mismo que en ejemplos anteriores, se modificaron los valores para mostrar una visualización más apreciable.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`rayMarch`:\n```glsl\nvec4 rayMarch(vec3 ro, vec3 rd) {\n  const float maxDistance = 100.0;\n  const float minDistance = 0.001;\n  const int maxIter = 100;\n  float totalDistance = 0.0;\n  vec3 p;\n  for (int i = 0; i &lt; maxIter; i++) {\n    p = ro + totalDistance * rd;\n    vec2 dfVec = distanceField(p);\n    float d = dfVec.x;\n    if (d &lt; minDistance) {\n      float effort = dfVec.y;\n      float g = effort;\n      float b = 1.0 - effort;\n      return vec4(0.0, g, b, 1.0);\n    }\n    totalDistance += d;\n    if (totalDistance &gt; maxDistance) {\n      break;\n    }\n  }\n  return vec4(0.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Se añadió un parámetro extra (`effort`) que representa cuantas iteraciones se realizaron para saber si una coordenada pertenece al conjunto (verde: muchas iteraciones, azul: pocas iteraciones).&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`distanceField`:\n```glsl\nvec2 distanceField(vec3 p) {\n  float angle = uTime / 10.0;\n  p = rotationY(angle) * p;\n  p = rotationX(PI / 2.0) * p;\n  return sdMandelbulb(p, 8.0);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Para apreciar el mejor el fractal, se hacen ligeras rotaciones.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;`sdMandelbulb`: 💀\n```glsl\nvec2 sdMandelbulb(vec3 p, float power) {\n  const int maxIter = 12;\n\n  vec3 zeta = p;\n  float dr = 1.0;\n  float r = 0.0;\n  int iterations = 0;\n  for (int _ = 0; _ &lt; maxIter; _++) {\n    iterations++;\n\n    vec3 spherical = toSpherical(zeta);\n    r = spherical.x;\n    if (r &gt; 2.0) {\n      break;\n    }\n\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n    float theta = spherical.y * power;\n    float phi = spherical.z * power;\n    float sinTheta = sin(theta);\n\n    float powx = pow(r, power) * sinTheta * cos(phi);\n    float powy = pow(r, power) * sinTheta * sin(phi);\n    float powz = pow(r, power) * cos(theta);\n\n    zeta.x = powx + p.x;\n    zeta.y = powy + p.y;\n    zeta.z = powz + p.z;\n  }\n  float d = 0.5 * log(r) * r / dr;\n  float effort = float(iterations) / float(maxIter);\n  return vec2(d, effort);\n}\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Esta función estima la distancia a una coordenada que pertenezca al conjunto de Mandelbulb. No comprendo muy bien el cálculo de `dr`, pero entiendo que es su propósito.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Adicionalmente, se añadió `effort` como una utilidad para distinguir entre los puntos del conjunto.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;En el ejemplo anterior se usa una potencia de 8, sin embargo, lo genial viene de probar distintos valores.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Update (2024-08-01)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Una referencia (para entrar a fondo) la pueden encontrar en el comentario `mandelbulbSDF.glsl` de `lygia`:\n\nhttps://github.com/patriciogonzalezvivo/lygia/blob/main/sdf/mandelbulbSDF.glsl#L40\n\n```glsl\n// distance estimation through the Hubbard-Douady potential from Inigo Quilez\nreturn vec2(0.25*log(m) * sqrt(m) / dz, iterations);\n```&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;No entiendo con certeza la similitud con lo que conseguí, pero obivo existe...&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Experimentos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## n = min(time, 8)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(angle) * p;\\n  // p = rotationX(PI / 2.0) * p;\\n  return sdMandelbulb(p, min(uTime, 8.0));\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float r = effort;\\n      float b = 1.0 - effort;\\n      return vec4(r, r/b, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 2.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Este es muy similar al del post anterior.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## n = 8, rotateXY(time)&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 12;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 2.0;\\n  p = rotationY(angle) * p;\\n  p = rotationX(angle) * p;\\n  return sdMandelbulb(p, 8.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.001;\\n  const int maxIter = 100;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float r = effort;\\n      float b = 1.0 - effort;\\n      return vec4(r, r/b, b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(0.0, 0.0, 2.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n}\\n\\nfunction draw() {\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;## Portada&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nuniform float uRes;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  pos = pos * 2.0 - 1.0;\\n  uv = pos.xy;\\n  uv.x *= uRes;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst explained = `\\nmat3 rotationX(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    1.0, 0.0, 0.0,\\n    0.0, c, -s,\\n    0.0, s, c\\n  );\\n}\\n\\nmat3 rotationY(float angle) {\\n  float c = cos(angle);\\n  float s = sin(angle);\\n  return mat3(\\n    c, 0.0, s,\\n    0.0, 1.0, 0.0,\\n    -s, 0.0, c\\n  );\\n}\\n\\nvec3 toSpherical(vec3 p) {\\n  float r = length(p);\\n  float theta = acos(p.z / r);\\n  float phi = atan(p.y, p.x);\\n  return vec3(r, theta, phi);\\n}\\n`;\\n\\nconst fragShader = `\\nprecision highp float;\\nvarying vec2 uv;\\nuniform float uTime;\\nconst float PI = 3.14159265;\\n\\n${explained}\\n\\nvec2 sdMandelbulb(vec3 p, float power) {\\n  const int maxIter = 10;\\n\\n  vec3 zeta = p;\\n  float dr = 1.0;\\n  float r = 0.0;\\n  int iterations = 0;\\n  for (int _ = 0; _ &lt; maxIter; _++) {\\n    iterations++;\\n\\n    vec3 spherical = toSpherical(zeta);\\n    r = spherical.x;\\n    if (r &gt; 2.0) {\\n      break;\\n    }\\n\\n    dr = pow(r, power - 1.0) * power * dr + 1.0;\\n\\n    float theta = spherical.y * power;\\n    float phi = spherical.z * power;\\n    float sinTheta = sin(theta);\\n\\n    float powx = pow(r, power) * sinTheta * cos(phi);\\n    float powy = pow(r, power) * sinTheta * sin(phi);\\n    float powz = pow(r, power) * cos(theta);\\n\\n    zeta.x = powx + p.x;\\n    zeta.y = powy + p.y;\\n    zeta.z = powz + p.z;\\n  }\\n  float d = 0.5 * log(r) * r / dr;\\n  float effort = float(iterations) / float(maxIter);\\n  return vec2(d, effort);\\n}\\n\\nvec2 distanceField(vec3 p) {\\n  float angle = uTime / 10.0;\\n  p = rotationY(PI * 3.0 / 2.0) * p;\\n  p = rotationX(PI * 5.0 / 4.0) * p;\\n  return sdMandelbulb(p, 6.0);\\n}\\n\\nvec4 rayMarch(vec3 ro, vec3 rd) {\\n  const float maxDistance = 100.0;\\n  const float minDistance = 0.0001;\\n  const int maxIter = 300;\\n  float totalDistance = 0.0;\\n  vec3 p;\\n  for (int i = 0; i &lt; maxIter; i++) {\\n    p = ro + totalDistance * rd;\\n    vec2 dfVec = distanceField(p);\\n    float d = dfVec.x;\\n    if (d &lt; minDistance) {\\n      float effort = dfVec.y;\\n      float b = sqrt(1.0 - effort);\\n      float a = 1.0 - b;\\n      return vec4(a, 0.6 * b/a, a*b, 1.0);\\n    }\\n    totalDistance += d;\\n    if (totalDistance &gt; maxDistance) {\\n      break;\\n    }\\n  }\\n  return vec4(0.0);\\n}\\n\\nvoid main() {\\n  vec3 ro = vec3(-0.6, 0.6, 1.0);\\n  vec3 rd = normalize(vec3(uv, -1.0));\\n  vec4 color = rayMarch(ro, rd);\\n  gl_FragColor = color;\\n}\\n`;\\n\\nlet initTime;\\nlet myShader;\\nfunction setup() {\\n  myShader = createShader(vertShader, fragShader);\\n  createCanvas(320, 320, WEBGL);\\n  initTime = new Date().getTime();\\n  background(0, 0, 0, 0);\\n  shader(myShader);\\n  const uTime = (new Date().getTime() - initTime) / 1000;\\n  myShader.setUniform(\\\&quot;uTime\\\&quot;, uTime);\\n  myShader.setUniform(\\\&quot;uRes\\\&quot;, width / height);\\n  rect(0, 0, 0, 0);\\n  // save(&#39;mandelbulb.jpg&#39;)\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Eso, el código con el que se creó la portada está en ese `iframe`.&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;# Recursos&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;- [Shaders en corto](/blog/shaders-en-corto)\n- https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n- https://wikipedia.org/wiki/Mandelbulb\n- https://editor.p5js.org/Taxen99/sketches/47CDg5-nV&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;---&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;Nota: A nivel personal me queda pendiente experimentar con estados previos para calcular el siguiente, así como en el juego de la vida del post anterior. Igual lo dejo again (copiar es gratis):&quot;],&quot;type&quot;:[0,&quot;MarkdownBlock&quot;]}],[0,{&quot;text&quot;:[0,&quot;{\&quot;html\&quot;:\&quot;&lt;!DOCTYPE html&gt;\\n&lt;html lang=\\\&quot;en\\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;script src=\\\&quot;https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\\\&quot;&gt;&lt;/script&gt;\\n    &lt;meta charset=\\\&quot;utf-8\\\&quot; /&gt;\\n  &lt;/head&gt;\\n  &lt;body&gt;\\n  &lt;/body&gt;\\n&lt;/html&gt;\\n\&quot;,\&quot;js\&quot;:\&quot;const vertShader = `\\nattribute vec3 aPosition;\\nvarying vec2 vXY;\\n\\nvoid main() {\\n  vec4 pos = vec4(aPosition, 1.0);\\n  vXY = pos.xy;\\n  pos = pos * 2.0 - 1.0;\\n  gl_Position = pos;\\n}\\n`;\\n\\nconst uStateSize = 320;\\nconst fragShader = `\\nprecision mediump float;\\nvarying vec2 vXY;\\nuniform sampler2D uState;\\nuniform vec2 uCircle;\\nfloat uStateSize = ${uStateSize}.0;\\n\\nfloat getState(int i, int j) {\\n  vec4 data = texture2D(\\n    uState,\\n    vec2(\\n      (float(i) + 0.5) / uStateSize,\\n      (float(j) - 0.5) / uStateSize\\n    )\\n  );\\n  return data.r;\\n}\\n\\nvoid main() {\\n  int i = int(vXY.x * uStateSize);\\n  int j = int(uStateSize) - int(vXY.y * uStateSize);\\n\\n  bool isAlive = getState(i, j) &gt; 0.0;\\n  float tl =  getState(i - 1, j - 1);\\n  float t =  getState(i, j - 1);\\n  float tr =  getState(i + 1, j - 1);\\n  float l =  getState(i - 1, j);\\n  float r =  getState(i + 1, j);\\n  float bl =  getState(i - 1, j + 1);\\n  float b =  getState(i, j + 1);\\n  float br =  getState(i + 1, j + 1);\\n  float n = tl + t + tr + l + r + bl + b + br;\\n\\n  if(isAlive) {\\n    float nowIsDead = float(n &lt; 1.1) + float(n &gt; 3.9);\\n    if(nowIsDead &gt; 0.1) isAlive = false;\\n  } else {\\n    float nowIsBorn = float(n &gt; 2.9) * float(n &lt; 3.1);\\n    if(nowIsBorn &gt; 0.1) isAlive = true;\\n  }\\n\\n  float circleDist = length((vXY*2.0-1.0) - uCircle);\\n  if(circleDist &lt; 0.08) isAlive = true;\\n\\n  gl_FragColor = vec4(vec3(float(isAlive)), 1.0);\\n}\\n`;\\n\\nlet myShader;\\nlet g;\\nfunction setup() {\\n  createCanvas(uStateSize, uStateSize, WEBGL);\\n  g = createGraphics(uStateSize, uStateSize, WEBGL);\\n  myShader = createShader(vertShader, fragShader);\\n  g.shader(myShader);\\n  g.background(0);\\n  g.stroke(255);\\n  for (let i = 0; i &lt; uStateSize; i++) {\\n    for (let j = 0; j &lt; uStateSize; j++) {\\n      if (random(1) &gt; 0.99) {\\n        let x = i - uStateSize / 2;\\n        let y = j - uStateSize / 2;\\n        g.point(x, y);\\n      }\\n    }\\n  }\\n}\\n\\nfunction draw() {\\n  const angle = frameCount / 80;\\n  const uCircle = [cos(angle) / 2, sin(angle) / 2];\\n  myShader.setUniform(\\\&quot;uState\\\&quot;, g);\\n  myShader.setUniform(\\\&quot;uCircle\\\&quot;, uCircle);\\n  g.rect(0, 0, 0, 0);\\n  imageMode(CENTER);\\n  image(g, 0, 0, width, height);\\n}\\n\&quot;,\&quot;css\&quot;:\&quot;html, body {\\n  margin: 0;\\n  padding: 0;\\n  background: black;\\n}\\ncanvas {\\n  display: block;\\n  margin: auto;\\n  image-rendering: pixelated;\\n  image-rendering: crisp-edges;\\n}\\n\&quot;}&quot;],&quot;type&quot;:[0,&quot;LiveCodeBlock&quot;]}]]],&quot;isPinned&quot;:[0,true],&quot;slugUrl&quot;:[0,&quot;mandelbulb-en-glsl&quot;]}]}" ssr client="load" opts="{&quot;name&quot;:&quot;PostView&quot;,&quot;value&quot;:true}" await-children><div class="flex-1 flex gap-8 flex-col w-full mx-auto p-2"><div class="flex flex-col gap-2"><div class="flex justify-between"><div class="text-neutral-400 text-xs">Junio 7, 2024</div><p class="text-neutral-400 text-xs flex gap-1">5 minutos de lectura </p></div><h1>Mandelbulb en GLSL</h1><!----><div class="flex gap-2 text-sm"><!--[--><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=art"> #art</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=edu"> #edu</a><!----></div><div class="flex gap-1"><a class="text-neutral-400 nounderline hover:underline hover:text-white" href="/blog/?c=tech"> #tech</a><!----></div><!--]--><!----></div><!----></div><div class="font-sans mb-[-0.5rem]"><h2 class="mb-3">Índice:</h2><div><!----><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#ray-marching-en-glsl" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Ray marching en GLSL"><p>Ray marching en GLSL</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#olvida-todo" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Olvida todo!"><p>Olvida todo!</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#mandelbulb" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Mandelbulb"><p>Mandelbulb</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#update-2024-08-01" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Update (2024-08-01)"><p>Update (2024-08-01)</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#experimentos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Experimentos"><p>Experimentos</p>
</a><ul><!--[--><li><a href="/blog/mandelbulb-en-glsl/#n-mintime-8" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="n = min(time, 8)"><p>n = min(time, 8)</p>
</a><!----></li><li><a href="/blog/mandelbulb-en-glsl/#n-8-rotatexytime" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="n = 8, rotateXY(time)"><p>n = 8, rotateXY(time)</p>
</a><!----></li><li><a href="/blog/mandelbulb-en-glsl/#portada" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Portada"><p>Portada</p>
</a><!----></li><!--]--></ul></li><li><a href="/blog/mandelbulb-en-glsl/#recursos" class="flex w-fit no-underline hover:underline cursor-pointer mb-2" title="Recursos"><p>Recursos</p>
</a><!----></li><!--]--></ul></div></div><hr><div class="flex flex-col justify-center gap-6 w-full"><!--[--><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta es la continuación espiritual de <a href="/blog/shaders-en-corto" title="null" class="text-primary [word-break:break-word]" target="_blank">shaders en corto</a>. Aquí describiré los pasos para renderizar Mandelbulb en GLSL.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex flex-col w-full"><img loading="lazy" class="w-auto h-80 object-contain bg-black bg-opacity-30" src="/blog/mandelbulb-en-glsl/img/mandelbulb.png"><!----></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Qué es Mandelbulb? un fractal en 3-dimensiones. De nada.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En el post previo se muestra Mandelbrot (un fractal en 2-dimensiones) como se muestra a continuación:</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Mandelbulb tiene la intención de mostrar como sería Mandelbrot en 3-dimensiones. Y si me equivoco, pues me equivoqué.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Trayectoria:</p>
<ul>
<li>Contexto: El objetivo es renderizar Mandelbulb en GLSL, por diversión 👍</li>
<li>Limitaciones: Conocimientos de <code>ray marching</code> prematuros y de álgebra lineal no muy remotos. (lado positivo: algunas cosas son caja negra)</li>
<li>Retroalimentación: No hay 👍</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>La intención es construir una versión propia, separada por partes (a mi manera (es una dictadura)).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="ray-marching-en-glsl">Ray marching en GLSL</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El <code>ray marching</code> es la técnica que se usará para renderizar Mandelbulb. Existen otras, es probable que también sirvan, pero parto de la asunción de que es posible ya que existen muchas implementaciones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta técnica es iterativa, busca la intersección entre un supuesto rayo de luz y un objeto. En otras palabras, se lanza un rayo de luz desde un punto de la pantalla hasta encontrar un objeto.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para aplicar la técnica en GLSL la parte importante es el <code>fragment shader</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El fragment shader es el siguiente:</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">precision</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">float</span>;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> uv;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uTime;

<span class="hljs-type">mat3</span> rotationX(<span class="hljs-type">float</span> angle) {
  <span class="hljs-type">float</span> c = <span class="hljs-built_in">cos</span>(angle);
  <span class="hljs-type">float</span> s = <span class="hljs-built_in">sin</span>(angle);
  <span class="hljs-keyword">return</span> <span class="hljs-type">mat3</span>(
    <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>,
    <span class="hljs-number">0.0</span>, c, -s,
    <span class="hljs-number">0.0</span>, s, c
  );
}

<span class="hljs-type">mat3</span> rotationY(<span class="hljs-type">float</span> angle) {
  <span class="hljs-type">float</span> c = <span class="hljs-built_in">cos</span>(angle);
  <span class="hljs-type">float</span> s = <span class="hljs-built_in">sin</span>(angle);
  <span class="hljs-keyword">return</span> <span class="hljs-type">mat3</span>(
    c, <span class="hljs-number">0.0</span>, s,
    <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,
    -s, <span class="hljs-number">0.0</span>, c
  );
}

<span class="hljs-type">float</span> sdCube(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">vec3</span> boxSize = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);
  <span class="hljs-type">vec3</span> d = <span class="hljs-built_in">abs</span>(p) - boxSize;
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">length</span>(<span class="hljs-built_in">max</span>(d, <span class="hljs-number">0.0</span>)) + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(d.x, <span class="hljs-built_in">max</span>(d.y, d.z)), <span class="hljs-number">0.0</span>);
}

<span class="hljs-type">float</span> distanceField(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> angle = uTime;
  p = rotationY(angle) * p;
  p = rotationX(angle) * p;
  <span class="hljs-keyword">return</span> sdCube(p);
}

<span class="hljs-type">vec3</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {

  <span class="hljs-comment">// Menor valor oculta la escena de de atrás hacia adelante</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;

  <span class="hljs-comment">// Menor valor oculta las esquinas de los objetos</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;

  <span class="hljs-comment">// Mayor valor aumenta la fidelidad de la imágen a mayor coste computacional</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;

  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxIter; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">float</span> d = distanceField(p);
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(p); <span class="hljs-comment">// Superficie</span>
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Fondo</span>
}

<span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec3</span> ro = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">4.0</span>); <span class="hljs-comment">// Posición del observador</span>
  <span class="hljs-type">vec3</span> rd = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(uv, <span class="hljs-number">-1.0</span>)); <span class="hljs-comment">// Dirección del rayo</span>

  <span class="hljs-type">vec3</span> color = rayMarch(ro, rd);

  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color, <span class="hljs-number">1.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="olvida-todo">Olvida todo!</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Son muchas cosas pero lo importante es <code>rayMarch</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec3</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {

  <span class="hljs-comment">// Menor valor oculta la escena de de atrás hacia adelante</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;

  <span class="hljs-comment">// Menor valor oculta las esquinas de los objetos</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;

  <span class="hljs-comment">// Mayor valor aumenta la fidelidad de la imágen a mayor coste computacional</span>
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;

  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">float</span> d = distanceField(p);
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(p); <span class="hljs-comment">// Superficie</span>
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>); <span class="hljs-comment">// Fondo</span>
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>A diferencia de otros métodos de renderizado, este es estimado. La parte más <em>relevante</em> es la que nos permite obtener la coordenada <code>p</code>. Se obtiene de forma iterativa, cuando la distancia cumple con la condición de ser menor a <code>minDistance</code> el punto <code>p</code> es considerado parte de la escena (de alguna superficie). Con ello se puede asignar un valor al color.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>El resto del código son utilidades (álgebra lineal: posiciones, rayos de luz, rotaciones, etc...). Para los objetos existen muchas funciones con las que se puede calcular la distancia a uno de ellos, puedes revisar:</p>
<ul>
<li><a href="https://iquilezles.org/articles/distfunctions/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://iquilezles.org/articles/distfunctions/</a> ✨</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En <code>distanceField</code> es donde se calculan las distancias a cada objeto, en este caso hace rotaciones y calcula la distancia a un cubo.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="mandelbulb">Mandelbulb</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>La referencia principal se toma del siguiente recurso:</p>
<ul>
<li><a href="https://editor.p5js.org/Taxen99/sketches/47CDg5-nV" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/Taxen99/sketches/47CDg5-nV</a> by Taxen99</li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>También sirve ver la referencia en wikipedia:</p>
<ul>
<li><a href="https://wikipedia.org/wiki/Mandelbulb" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://wikipedia.org/wiki/Mandelbulb</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Pasos:</p>
<ol>
<li>Evaluar el punto en un área de 3-dimensiones.</li>
<li>Calcular si pertenece al conjunto dado un <em>criterio</em>.</li>
</ol>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Suena simple pero el criterio es extenso. Primero es necesario pasar la coordenada <code>p</code> a coordenadas esféricas:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec3</span> toSpherical(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> r = <span class="hljs-built_in">length</span>(p);
  <span class="hljs-type">float</span> theta = <span class="hljs-built_in">acos</span>(p.z / r);
  <span class="hljs-type">float</span> phi = <span class="hljs-built_in">atan</span>(p.y, p.x);
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(r, theta, phi);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>No puedo decir mucho, la fórmula de White y Nylander hacen posible el cálculo del conjunto de Mandelbulb. ✨</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para no entrar en mucho detalle, empecemos del <code>main</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">void</span> main() {
  <span class="hljs-type">vec3</span> ro = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.6</span>);
  <span class="hljs-type">vec3</span> rd = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(uv, <span class="hljs-number">-1.0</span>));
  <span class="hljs-type">vec4</span> color = rayMarch(ro, rd);
  <span class="hljs-built_in">gl_FragColor</span> = color;
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Es lo mismo que en ejemplos anteriores, se modificaron los valores para mostrar una visualización más apreciable.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>rayMarch</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec4</span> rayMarch(<span class="hljs-type">vec3</span> ro, <span class="hljs-type">vec3</span> rd) {
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxDistance = <span class="hljs-number">100.0</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minDistance = <span class="hljs-number">0.001</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">100</span>;
  <span class="hljs-type">float</span> totalDistance = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">vec3</span> p;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxIter; i++) {
    p = ro + totalDistance * rd;
    <span class="hljs-type">vec2</span> dfVec = distanceField(p);
    <span class="hljs-type">float</span> d = dfVec.x;
    <span class="hljs-keyword">if</span> (d &lt; minDistance) {
      <span class="hljs-type">float</span> effort = dfVec.y;
      <span class="hljs-type">float</span> g = effort;
      <span class="hljs-type">float</span> b = <span class="hljs-number">1.0</span> - effort;
      <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, g, b, <span class="hljs-number">1.0</span>);
    }
    totalDistance += d;
    <span class="hljs-keyword">if</span> (totalDistance &gt; maxDistance) {
      <span class="hljs-keyword">break</span>;
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Se añadió un parámetro extra (<code>effort</code>) que representa cuantas iteraciones se realizaron para saber si una coordenada pertenece al conjunto (verde: muchas iteraciones, azul: pocas iteraciones).</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>distanceField</code>:</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec2</span> distanceField(<span class="hljs-type">vec3</span> p) {
  <span class="hljs-type">float</span> angle = uTime / <span class="hljs-number">10.0</span>;
  p = rotationY(angle) * p;
  p = rotationX(PI / <span class="hljs-number">2.0</span>) * p;
  <span class="hljs-keyword">return</span> sdMandelbulb(p, <span class="hljs-number">8.0</span>);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Para apreciar el mejor el fractal, se hacen ligeras rotaciones.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p><code>sdMandelbulb</code>: 💀</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec2</span> sdMandelbulb(<span class="hljs-type">vec3</span> p, <span class="hljs-type">float</span> power) {
  <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> maxIter = <span class="hljs-number">12</span>;

  <span class="hljs-type">vec3</span> zeta = p;
  <span class="hljs-type">float</span> dr = <span class="hljs-number">1.0</span>;
  <span class="hljs-type">float</span> r = <span class="hljs-number">0.0</span>;
  <span class="hljs-type">int</span> iterations = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> _ = <span class="hljs-number">0</span>; _ &lt; maxIter; _++) {
    iterations++;

    <span class="hljs-type">vec3</span> spherical = toSpherical(zeta);
    r = spherical.x;
    <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">2.0</span>) {
      <span class="hljs-keyword">break</span>;
    }

    dr = <span class="hljs-built_in">pow</span>(r, power - <span class="hljs-number">1.0</span>) * power * dr + <span class="hljs-number">1.0</span>;

    <span class="hljs-type">float</span> theta = spherical.y * power;
    <span class="hljs-type">float</span> phi = spherical.z * power;
    <span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sin</span>(theta);

    <span class="hljs-type">float</span> powx = <span class="hljs-built_in">pow</span>(r, power) * sinTheta * <span class="hljs-built_in">cos</span>(phi);
    <span class="hljs-type">float</span> powy = <span class="hljs-built_in">pow</span>(r, power) * sinTheta * <span class="hljs-built_in">sin</span>(phi);
    <span class="hljs-type">float</span> powz = <span class="hljs-built_in">pow</span>(r, power) * <span class="hljs-built_in">cos</span>(theta);

    zeta.x = powx + p.x;
    zeta.y = powy + p.y;
    zeta.z = powz + p.z;
  }
  <span class="hljs-type">float</span> d = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">log</span>(r) * r / dr;
  <span class="hljs-type">float</span> effort = <span class="hljs-type">float</span>(iterations) / <span class="hljs-type">float</span>(maxIter);
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec2</span>(d, effort);
}
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Esta función estima la distancia a una coordenada que pertenezca al conjunto de Mandelbulb. No comprendo muy bien el cálculo de <code>dr</code>, pero entiendo que es su propósito.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Adicionalmente, se añadió <code>effort</code> como una utilidad para distinguir entre los puntos del conjunto.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>En el ejemplo anterior se usa una potencia de 8, sin embargo, lo genial viene de probar distintos valores.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="update-2024-08-01">Update (2024-08-01)</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Una referencia (para entrar a fondo) la pueden encontrar en el comentario <code>mandelbulbSDF.glsl</code> de <code>lygia</code>:</p>
<p><a href="https://github.com/patriciogonzalezvivo/lygia/blob/main/sdf/mandelbulbSDF.glsl#L40" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://github.com/patriciogonzalezvivo/lygia/blob/main/sdf/mandelbulbSDF.glsl#L40</a></p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// distance estimation through the Hubbard-Douady potential from Inigo Quilez</span>
<span class="hljs-keyword">return</span> <span class="hljs-type">vec2</span>(<span class="hljs-number">0.25</span>*<span class="hljs-built_in">log</span>(m) * <span class="hljs-built_in">sqrt</span>(m) / dz, iterations);
</code></pre></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>No entiendo con certeza la similitud con lo que conseguí, pero obivo existe...</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="experimentos">Experimentos</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="n-mintime-8">n = min(time, 8)</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Este es muy similar al del post anterior.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="n-8-rotatexytime">n = 8, rotateXY(time)</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h2 class="font-mono" id="portada">Portada</h2></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Eso, el código con el que se creó la portada está en ese <code>iframe</code>.</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><h1 class="font-mono" id="recursos">Recursos</h1></div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><ul>
<li><a href="/blog/shaders-en-corto" title="null" class="text-primary [word-break:break-word]" target="_blank">Shaders en corto</a></li>
<li><a href="https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/</a></li>
<li><a href="https://wikipedia.org/wiki/Mandelbulb" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://wikipedia.org/wiki/Mandelbulb</a></li>
<li><a href="https://editor.p5js.org/Taxen99/sketches/47CDg5-nV" title="undefined" class="text-primary [word-break:break-word]" target="_blank">https://editor.p5js.org/Taxen99/sketches/47CDg5-nV</a></li>
</ul>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><hr>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="flex w-full justify-between text-lg" slugurl="mandelbulb-en-glsl"><div class="font-sans w-full"><p>Nota: A nivel personal me queda pendiente experimentar con estados previos para calcular el siguiente, así como en el juego de la vida del post anterior. Igual lo dejo again (copiar es gratis):</p>
</div></div><!----></div><div class="relative flex flex-col justify-center w-full"><div class="w-full flex flex-col bg-black" slugurl="mandelbulb-en-glsl"><!----><!----><button class="bg-primary" title="Reiniciar">►</button><iframe class="h-80" srcdoc="&lt;html&gt;&lt;head&gt;&lt;style&gt;body{background-color:black}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"></iframe></div><!----></div><!--]--></div></div><!--astro:end--></astro-island>  <footer class="flex flex-col gap-4 px-2 py-8 mt-8 border-t border-neutral-500 w-full text-neutral-500 text-xs print:hidden"> <div class="flex whitespace-nowrap"> <div class="flex-1 flex flex-col gap-1"> <!-- <p class="pl-2">Left</p> --> <ul class="flex flex-col gap-1"> <li> <a class="hover:text-white" href="/"> Inicio </a> </li><li> <a class="hover:text-white" href="/blog"> Blog </a> </li> </ul> </div> <div class="flex-1 flex flex-col gap-1 ml-auto text-right"> <!-- <p class="pr-2">Rright</p> --> <ul class="flex flex-col gap-1 text-right [direction:rtl]"> <li> <a class="hover:text-white" href="/blog/sobre-mi"> Sobre mi </a> </li> </ul> </div> </div> <div class="flex justify-between w-full"> <p> <!-- First post: /blog/sobre-mi -->
&copy; 2018.
<a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/" class="hover:text-white">CC BY-SA 4.0</a> </p> </div> </footer> </div>  </body></html> 